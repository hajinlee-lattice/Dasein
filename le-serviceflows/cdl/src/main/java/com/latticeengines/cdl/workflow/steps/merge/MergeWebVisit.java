package com.latticeengines.cdl.workflow.steps.merge;

import static com.latticeengines.domain.exposed.metadata.InterfaceName.CDLCreatedTemplate;
import static com.latticeengines.domain.exposed.metadata.InterfaceName.LatticeAccountId;
import static com.latticeengines.domain.exposed.metadata.TableRoleInCollection.ConsolidateWebVisit;
import static com.latticeengines.domain.exposed.query.BusinessEntity.Account;
import static com.latticeengines.domain.exposed.query.BusinessEntity.ActivityStream;
import static com.latticeengines.domain.exposed.query.BusinessEntity.LatticeAccount;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.collections4.SetUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.latticeengines.common.exposed.util.JsonUtils;
import com.latticeengines.common.exposed.validator.annotation.NotNull;
import com.latticeengines.domain.exposed.camille.CustomerSpace;
import com.latticeengines.domain.exposed.cdl.activity.ActivityImport;
import com.latticeengines.domain.exposed.cdl.activity.AtlasStream;
import com.latticeengines.domain.exposed.datacloud.manage.Column;
import com.latticeengines.domain.exposed.datacloud.match.MatchInput;
import com.latticeengines.domain.exposed.datacloud.match.MatchKey;
import com.latticeengines.domain.exposed.datacloud.match.OperationalMode;
import com.latticeengines.domain.exposed.datacloud.transformation.PipelineTransformationRequest;
import com.latticeengines.domain.exposed.datacloud.transformation.config.impl.MatchTransformerConfig;
import com.latticeengines.domain.exposed.datacloud.transformation.step.TransformationStepConfig;
import com.latticeengines.domain.exposed.metadata.InterfaceName;
import com.latticeengines.domain.exposed.metadata.TableRoleInCollection;
import com.latticeengines.domain.exposed.propdata.manage.ColumnSelection;
import com.latticeengines.domain.exposed.query.BusinessEntity;
import com.latticeengines.domain.exposed.security.Tenant;
import com.latticeengines.domain.exposed.serviceflows.cdl.steps.process.ProcessActivityStreamStepConfiguration;

@Component(MergeWebVisit.BEAN_NAME)
@Lazy
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MergeWebVisit extends BaseActivityStreamStep<ProcessActivityStreamStepConfiguration> {

    /**
     * this step used when tenant enable SSVI flag, disable CDL flag.
     * if enable CDL flag, will skip this step.
     */

    static final String BEAN_NAME = "mergeWebVisit";

    private static final Logger log = LoggerFactory.getLogger(MergeWebVisit.class);

    // matched table of merged imports
    private static final String WEBVISIT_MATCHED_PREFIX_FORMAT = "Matched_WebVisit_%s";
    // matched table merged with existing batch store, used as input of rematch step
    private static final String WEBVISIT_PRE_REMATCH_TABLE_PREFIX_FORMAT = "PreReMatch_WebVisit_%s";
    // rematched table of merged imports + active batch store
    private static final String WEBVISIT_REMATCHED_TABLE_PREFIX_FORMAT = "ReMatched_WebVisit_%s";

    private static final Set<String> DISCARD_ATTRS_IN_REMATCH = ImmutableSet.of(LatticeAccountId.name(),
            CDLCreatedTemplate.name()); // attrs generated by match and should be removed before rematch

    private static final List<String> WEBVISIT_LDC_ATTRIBUTES = ImmutableList.of("LE_GlobalUlt_salesUSD",
            "LE_DomUlt_SalesUSD", "LE_GlobalULt_EmployeeTotal", "LE_DomUlt_EmployeeTotal", "LDC_DUNS", "DOMESTIC_ULTIMATE_DUNS_NUMBER",
            "GLOBAL_ULTIMATE_DUNS_NUMBER", "LE_SIC_CODE", "LE_Site_NAICS_Code", "LE_INDUSTRY", "LE_EMPLOYEE_RANGE",
            "LE_REVENUE_RANGE", "LE_IS_PRIMARY_DOMAIN", "LDC_Domain", "LDC_Name", "LDC_Country", "LDC_State",
            "LDC_City", "LE_DNB_TYPE");

    // streamId -> set of column names
    private final Map<String, Set<String>> streamImportColumnNames = new HashMap<>();
    // streamId -> stream object
    private Map<String, AtlasStream> webVisitStreamMap = new HashMap<>();
    // streamId -> list({ tableName, original import file name })
    @JsonProperty("stream_imports")
    private Map<String, List<ActivityImport>> webVisitImports = new HashMap<>();
    // streamId -> table prefix of matched webVisit raw streams imports processed by
    // transformation request
    private final Map<String, String> matchedTablePrefixes = new HashMap<>();
    // streamId -> root operation uid used for bulk match
    private final Map<String, String> matchRootOperationUids = new HashMap<>();
    private final Map<String, String> webVisitBatchStoreTables = new HashMap<>();
    private long currentTime;

    @Override
    protected void initializeConfiguration() {
        super.initializeConfiguration();
        currentTime = getCurrentTimestamp();
        log.info("Timestamp used as current time to build raw stream = {}", currentTime);
        log.info("IsRematch={}, isReplace={}", configuration.isRematchMode(), configuration.isReplaceMode());
        getWebVisitStreamMap();
        buildWebVisitImportColumnNames();
    }

    @Override
    protected PipelineTransformationRequest getConsolidateRequest() {
        if (Boolean.TRUE.equals(getObjectFromContext(IS_CDL_TENANT, Boolean.class))) {
            log.info("This is CDL Tenant, skip this step.");
            return null;
        }

        if (MapUtils.isEmpty(webVisitImports) || MapUtils.isEmpty(webVisitStreamMap)) {
            log.info("no import or atlasStream is null, will skip this step.");
            return null;
        }

        PipelineTransformationRequest request = new PipelineTransformationRequest();
        request.setName(BEAN_NAME);

        List<TransformationStepConfig> steps = new ArrayList<>();

        /*-
         * normal steps:
         * 1. merge imports
         * 2. match against current universe
         */
        Map<String, Integer> matchedImportTableIdx = webVisitImports.entrySet() //
                .stream() //
                .map(entry -> {
                    String streamId = entry.getKey();
                    List<String> importTables = entry.getValue() //
                            .stream() //
                            .map(ActivityImport::getTableName) //
                            .collect(Collectors.toList());
                    if (CollectionUtils.isEmpty(importTables)) {
                        return null;
                    }

                    // add concat/match step
                    return Pair.of(streamId, concatAndMatchStreamImports(streamId, importTables, steps));
                }) //
                .filter(Objects::nonNull) //
                .collect(Collectors.toMap(Pair::getKey, Pair::getValue));

        /*-
         * additional rematch steps:
         * 1. merge matched imports with batch store (if exist) and treat as a huge import
         * 2. rematch against empty universe
         */
        if (configuration.isRematchMode()) {
            log.info("Adding rematch steps, matchedImportTableIdx = {}", matchedImportTableIdx);
            webVisitBatchStoreTables.putAll(getActiveWebVisitTables(configuration.getCustomerSpace().toString(),
                    new ArrayList<>(webVisitStreamMap.values())));
            putObjectInContext(SSVI_WEBVISIT_RAW_TABLES, webVisitBatchStoreTables);
            webVisitStreamMap.forEach((streamId, stream) -> {
                Integer matchedStepIdx = matchedImportTableIdx.get(streamId);
                String activeTable = webVisitBatchStoreTables.get(streamId);
                appendRawStream(steps, stream, currentTime, matchedStepIdx, activeTable,
                        WEBVISIT_PRE_REMATCH_TABLE_PREFIX_FORMAT, DISCARD_ATTRS_IN_REMATCH).ifPresent(pair -> {
                    int appendStepIdx = pair.getValue();
                    // input table columns = [ import columns ] union [ active batch store columns ]
                    Set<String> columns = new HashSet<>(
                            streamImportColumnNames.getOrDefault(streamId, new HashSet<>()));
                    if (activeTable != null) {
                        columns.addAll(getTableColumnNames(activeTable));
                    }
                    addMatchStep(stream, columns, steps, appendStepIdx, true);
                });
            });
        }

        if (CollectionUtils.isEmpty(steps)) {
            log.info("No existing/new webvisit found, skip MergeWebvisit step");
            return null;
        }

        request.setSteps(steps);
        return request;
    }

    @Override
    protected void onPostTransformationCompleted() {
        Map<String, String> matchedTablenames = getFullTablenames(matchedTablePrefixes);
        log.info("Matched raw stream tables, tables={}, pipelineVersion={}", matchedTablenames, pipelineVersion);
        putObjectInContext(SSVI_MATCH_STREAM_TARGETTABLE, matchedTablenames);
    }

    private void getWebVisitStreamMap() {
        if (MapUtils.isEmpty(configuration.getActivityStreamMap())) {
            return;
        }
        configuration.getActivityStreamMap().forEach((streamId, stream) -> {
            if (AtlasStream.StreamType.WebVisit.equals(stream.getStreamType())) {
                webVisitStreamMap.put(streamId, stream);
                if (configuration.getStreamImports().get(streamId) != null) {
                    webVisitImports.put(streamId, configuration.getStreamImports().get(streamId));
                }
            }
        });
    }

    private Integer concatAndMatchStreamImports(@NotNull String streamId, @NotNull List<String> importTables,
                                                @NotNull List<TransformationStepConfig> steps) {
        AtlasStream stream = webVisitStreamMap.get(streamId);
        Set<String> importTableColumns = streamImportColumnNames.get(streamId);
        Preconditions.checkNotNull(stream, String.format("Stream %s is not in config", stream));
        Preconditions.checkArgument(CollectionUtils.isNotEmpty(stream.getMatchEntities()),
                String.format("Stream %s does not have match entities", streamId));

        // concat import
        steps.add(dedupAndConcatTables(null, false, importTables));
        addMatchStep(stream, importTableColumns, steps, steps.size() - 1, false);
        return steps.size() - 1;
    }

    private void addMatchStep(@NotNull AtlasStream stream, @NotNull Set<String> importTableColumns,
                              @NotNull List<TransformationStepConfig> steps, int matchInputTableIdx, boolean isRematchMode) {
        String tablePrefixFormat = isRematchMode ? WEBVISIT_REMATCHED_TABLE_PREFIX_FORMAT
                : WEBVISIT_MATCHED_PREFIX_FORMAT;
        String matchedTablePrefix = String.format(tablePrefixFormat, stream.getStreamId());
        String matchConfig;
        MatchInput baseMatchInput = getBaseMatchInput();
        // set stream type to source entity to get higher concurrency
        baseMatchInput.setSourceEntity(stream.getStreamType().name());
        if (configuration.getEntityMatchConfiguration() != null) {
            log.info("found custom entity match configuration = {}", configuration.getEntityMatchConfiguration());
            baseMatchInput.setEntityMatchConfiguration(configuration.getEntityMatchConfiguration());
        }

        String uid = UUID.randomUUID().toString();
        matchRootOperationUids.put(stream.getStreamId(), uid);
        // match entity
        matchConfig = getAllocateIdMatchConfigForAccount(customerSpace.toString(), baseMatchInput,
                importTableColumns, uid);
        // record the final table prefix for webVisit stream
        matchedTablePrefixes.put(stream.getStreamId(), matchedTablePrefix);
        steps.add(match(matchInputTableIdx, matchedTablePrefix, matchConfig));
    }

    private String getAllocateIdMatchConfigForAccount(String customer, MatchInput baseMatchInput,
                                                            Set<String> columnNames, String rootOperationUid) {
        MatchTransformerConfig config = new MatchTransformerConfig();
        baseMatchInput.setOperationalMode(OperationalMode.CDL_LOOKUP);
        baseMatchInput.setTargetEntity(LatticeAccount.name());
        baseMatchInput.setAllocateId(true);
        baseMatchInput.setOutputNewEntities(false);

        if (StringUtils.isNotBlank(rootOperationUid)) {
            config.setRootOperationUid(rootOperationUid);
        }
        baseMatchInput.setIncludeLineageFields(true);
        baseMatchInput.setCustomSelection(setCustomFieldSelection());
        baseMatchInput.setTenant(new Tenant(CustomerSpace.parse(customer).toString()));
        baseMatchInput.setKeyMap(getAccountMatchKeys(columnNames, MatchUtils.getSkippedMatchFields(baseMatchInput,
                Account.name())));
        baseMatchInput.setUseDnBCache(true);
        baseMatchInput.setUseRemoteDnB(true);

        config.setMatchInput(baseMatchInput);
        return JsonUtils.serialize(config);
    }

    private ColumnSelection setCustomFieldSelection() {
        List<Column> customFields =
                WEBVISIT_LDC_ATTRIBUTES.stream().map( col -> new Column(col, col)).collect(Collectors.toList());
        ColumnSelection customFieldSelection = new ColumnSelection();
        customFieldSelection.setColumns(customFields);
        return customFieldSelection;
    }

    private static Map<MatchKey, List<String>> getAccountMatchKeys(Set<String> columnNames, Set<String> fieldsToSkip) {

        Set<String> skippedFields = SetUtils.emptyIfNull(fieldsToSkip);
        log.info("Account match fields to skip from input {}, fields actually skipped {}", skippedFields,
                SetUtils.intersection(columnNames, skippedFields));
        columnNames = SetUtils.difference(columnNames, skippedFields);

        Map<MatchKey, List<String>> matchKeys = new HashMap<>();
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.Domain, InterfaceName.Website.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.DUNS, InterfaceName.DUNS.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.Name, InterfaceName.CompanyName.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.City, InterfaceName.City.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.State, InterfaceName.State.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.Country, InterfaceName.Country.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.PhoneNumber, InterfaceName.PhoneNumber.name());
        MatchUtils.addMatchKeyIfExists(columnNames, matchKeys, MatchKey.Zipcode, InterfaceName.PostalCode.name());
        log.info("Account match keys = {}", JsonUtils.serialize(matchKeys));
        return matchKeys;
    }

    private void buildWebVisitImportColumnNames() {
        if (MapUtils.isEmpty(webVisitImports)) {
            return;
        }

        webVisitImports.forEach((streamId, imports) -> {
            String[] importTables = imports.stream().map(ActivityImport::getTableName).toArray(String[]::new);
            Set<String> columns = getTableColumnNames(importTables);
            log.info("Stream {} has {} imports, {} total columns", streamId, imports.size(), columns.size());
            streamImportColumnNames.put(streamId, columns);
        });
    }

    /*-
     * table names in current active version for WebVisit
     */
    private Map<String, String> getActiveWebVisitTables(@NotNull String customerSpace,
                                                              List<AtlasStream> streams) {
        return getActiveTables(customerSpace, ActivityStream, streams, AtlasStream::getStreamId,
                ConsolidateWebVisit);
    }

    private <E> Map<String, String> getActiveTables(@NotNull String customerSpace, @NotNull BusinessEntity entity,
                                                    List<E> activityStoreEntities, Function<E, String> getUniqueIdFn, TableRoleInCollection role) {
        if (CollectionUtils.isEmpty(activityStoreEntities)) {
            return Collections.emptyMap();
        }

        List<String> uniqueIds = activityStoreEntities.stream() //
                .filter(Objects::nonNull) //
                .map(getUniqueIdFn) //
                .filter(StringUtils::isNotBlank) //
                .collect(Collectors.toList());
        Map<String, String> tables = dataCollectionProxy.getTableNamesWithSignatures(customerSpace, role, null,
                uniqueIds);
        log.info("Current {} tables for tenant {} are {}. StreamIds={}", entity, customerSpace, tables, uniqueIds);
        return tables;
    }
}
