package com.latticeengines.datacloudapi.engine.purge.service.impl;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.hadoop.fs.FileStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import com.latticeengines.common.exposed.util.HdfsUtils;
import com.latticeengines.domain.exposed.datacloud.manage.PurgeStrategy;
import com.latticeengines.domain.exposed.datacloud.manage.PurgeStrategy.SourceType;

/**
 * Targeting source:
 *
 * 1. Temporary source generated by transformation pipeline whose source name
 * has prefix "Pipeline_"
 *
 * 2. Source of non-production use generated by testing pipeline whose source
 * name has prefix "LDCDEV_"
 *
 * When to purge a temp source:
 *
 * After {@link #PurgeStrategy.getHdfsDays}} number of days of source's
 * existence on HDFS. {@link #PurgeStrategy.getHdfsVersions}} is not honored.The
 * entire source will be purged, not certain version.
 */
@Component("tempSourcePurger")
public class TempSourcePurger extends CollectionPurger {

    @SuppressWarnings("unused")
    private static Logger log = LoggerFactory.getLogger(TempSourcePurger.class);

    @Override
    protected SourceType getSourceType() {
        return SourceType.TEMP_SOURCE;
    }

    // SourceName -> HdfsPath
    @Override
    protected Map<String, List<String>> findSourcePaths(PurgeStrategy strategy, final boolean debug) {
        String basePath = hdfsPathBuilder.constructSourceBaseDir().toString();

        HdfsUtils.HdfsFileFilter filter = new HdfsUtils.HdfsFileFilter() {
            @Override
            public boolean accept(FileStatus file) {
                if (file == null) {
                    return false;
                }
                String name = file.getPath().getName().toString();
                if (!name.startsWith(strategy.getSource())) {
                    return false;
                }
                if (debug) {
                    return true;
                }
                long lastModifiedTime = file.getModificationTime();
                if (System.currentTimeMillis() - lastModifiedTime <= strategy.getHdfsDays() * DAY_IN_MS) {
                    return false;
                }
                return true;
            }

        };

        List<FileStatus> files = new ArrayList<>();
        try {
            files = HdfsUtils.getFileStatusesForDir(yarnConfiguration, basePath, filter);
        } catch (IOException e) {
            throw new RuntimeException("Fail to get source names in path " + basePath, e);
        }
        Map<String, List<String>> sourcePaths = new HashMap<>();
        files.forEach(file -> {
            String fullPath = file.getPath().toString();
            // Don't use source name in PurgeStrategy due to it's only prefix of
            // a source name
            sourcePaths.put(file.getPath().getName(),
                    Arrays.asList(fullPath.toString().substring(fullPath.indexOf(basePath))));
        });

        return sourcePaths;
    }

    @Override
    public boolean isSourceExisted(PurgeStrategy strategy) {
        return true; // for temp source no need to check path for finding sourceToPurge
    }

}
