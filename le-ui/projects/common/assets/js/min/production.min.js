angular.module('mainApp.appCommon.directives.charts.ArcChartDirective', [])
.directive('arcChart', function ($window) {
    return {
        restrict: 'EA',
        scope: {},
        link: function (scope, element, attrs) {
            var chartSize = attrs.chartSize;
            var color = attrs.chartColor;
            var value = attrs.chartValue;
            var total = attrs.chartTotal;
            var label = attrs.chartLabel;
            // Browser onresize event
            window.onresize = function() {
                scope.$apply();
            };
            
            // Watch for resize event
            scope.$watch(function () {
                return angular.element($window)[0].innerWidth;
            }, function () {
                scope.render();
            });
            
            scope.render = function () {
                
                var twoPi = 2 * Math.PI;
                $(element[0]).empty();
                var svg = d3.select(element[0]).append("svg")
                    .attr("width", chartSize)
                    .attr("height", chartSize)
                    .append("g")
                    .attr("transform", "translate(" + chartSize / 2 + "," + chartSize / 2 + ")");
                var arc = d3.svg.arc()
                    .startAngle(0)
                    .innerRadius((chartSize/2)-9)
                    .outerRadius(chartSize/2);
                
                // Add the background arc, from 0 to 100% (Ï„).
                var background = svg.append("path")
                    .datum({endAngle: twoPi})
                    .style("fill", "#DDDDDD")
                    .attr("d", arc);
                
                // Add the foreground arc
                var foreground = svg.append("path")
                    .datum({endAngle: 0})
                    .style("fill", color)
                    .attr("d", arc);
                
                function arcTween(transition, newAngle) {
                    transition.attrTween("d", function(d) {
                        var interpolate = d3.interpolate(d.endAngle, newAngle);
                        return function(t) {
                            d.endAngle = interpolate(t);
                            return arc(d);
                        };
                    });
                }
                
                foreground
                    .transition()
                    .duration(1000)
                    .call(arcTween, (value/total) * twoPi);
                
                // Add value to the middle of the arc
                svg.append("text")
                    .attr("class", "arc-chart-value")
                    .style("fill", "#555555")
                    .attr("dy", ".20em")
                    .text(value);
                
                // Add a label below the arc if it exists
                if (label != null) {
                    svg.append("text")
                        .attr("class", "arc-chart-label")
                        .attr("dy", "1.85em")
                        .style("fill", "#BBBBBB")
                        .text(label);
                }
            };
        }
    };
});
angular.module('mainApp.appCommon.directives.helperMarkDirective', [
    'mainApp.appCommon.directives.ngQtipDirective'
])
.directive('helperMark', function () {
    return {
        restrict: 'E',
        scope: {help: '@'},
        template: '<span class="has-tooltip" ng-qtip title="{{help}}"><i class="fa fa-question-circle"></i></span>'
    };
});

angular.module('mainApp.appCommon.directives.ngEnterDirective', [])
.directive('ngEnter', function () {
    return function (scope, element, attrs) {
        element.bind("keydown keypress", function (event) {
            if (event.which === 13) {
                scope.$apply(function () {
                    scope.$eval(attrs.ngEnter);
                });
 
                event.preventDefault();
            }
        });
    };
});
angular.module('mainApp.appCommon.directives.ngQtipDirective', [])
    .directive('ngQtip', function () {
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                return $(element).qtip({
                    content: attrs.title,
                    style: 'qtip-bootstrap'
                });
            }
        };
    });
angular.module('mainApp.appCommon.utilities.AnalyticAttributeUtility', [
    'mainApp.appCommon.utilities.ResourceUtility',
    'mainApp.appCommon.utilities.DateTimeFormatUtility',
    'mainApp.appCommon.utilities.NumberUtility'
])
.service('AnalyticAttributeUtility', function (ResourceUtility, DateTimeFormatUtility, NumberUtility) {

    // Enum used to determine whether a bucket should be shown
    this.ApprovedUsage = {
        None: "None",
        Model: "Model",
        ModelAndModelInsights: "ModelAndModelInsights",
        ModelAndAllInsights: "ModelAndAllInsights",
        IndividualDisplay: "IndividualDisplay"
    };

    // Enum used to determine attribute type information
    this.DataType = {
        String: "STRING",
        LongString: "LONGSTRING",
        Date: "DATE",
        DateTime: "DATETIME",
        Time: "TIME",
        Double: "DOUBLE",
        Float: "FLOAT",
        Int: "INT",
        Integer: "INTEGER",
        Short: "SHORT",
        Long: "LONG",
        Boolean: "BOOLEAN",
        Bit: "BIT",
        Epoch: "EPOCHTIME"
    };

    // Enum used to determine attribute type semantics
    this.FundamentalType = {
        Email: "EMAIL",
        Probability: "PROBABILITY",
        Phone: "PHONE",
        Enum: "ENUM",
        URI: "URI",
        Currency: "CURRENCY",
        Percent: "PERCENT",
        Year: "YEAR",
        Boolean: "BOOLEAN",
        Numeric: "NUMERIC"
    };

    this.FindAttributeMetadataData = function (modelSummary, attributeData) {
        var self = this;
        if (attributeData == null ||
            modelSummary == null ||
            modelSummary.AttributeMetadata == null ||
            modelSummary.AttributeMetadata.length === 0) {
            return null;
        }

        for (var i = 0; i < modelSummary.AttributeMetadata.length; i++) {
            if (attributeData.AttributeName == modelSummary.AttributeMetadata[i].ColumnName) {
                return modelSummary.AttributeMetadata[i];
            }
        }

        return null;
    };

    this.FindAttributeBucket = function (modelSummary, attributeData) {
        var self = this;
        if (attributeData == null ||
            modelSummary == null ||
            modelSummary.Summary == null ||
            modelSummary.Summary.Predictors == null ||
            modelSummary.Summary.Predictors.length === 0) {
            return null;
        }

        var predictor = null;
        for (var i = 0; i < modelSummary.Summary.Predictors.length; i++) {
            if (attributeData.AttributeName == modelSummary.Summary.Predictors[i].Name) {
                predictor = modelSummary.Summary.Predictors[i];
                break;
            }
        }

        if (predictor == null || predictor.Elements == null || predictor.Elements.length === 0) {
            return null;
        }

        for (var x = 0; x < predictor.Elements.length; x++) {
            var bucket = predictor.Elements[x];
            if (bucket.Values != null && bucket.Values.length > 0) {
                // We are working with Discrete values
                for (var y = 0; y < bucket.Values.length; y++) {
                    if (attributeData.AttributeValue == bucket.Values[y]) {
                        return bucket;
                    }
                }
            } else {
                var lowerBound = bucket.LowerInclusive != null ? parseFloat(bucket.LowerInclusive) : null;
                var upperBound = bucket.UpperExclusive != null ? parseFloat(bucket.UpperExclusive) : null;
                var parsedAttributeValue = attributeData.AttributeValue != null ? parseFloat(attributeData.AttributeValue) : null;
                if (parsedAttributeValue >= lowerBound && (parsedAttributeValue < upperBound || upperBound == null)) {
                    return bucket;
                }
            }
        }

        return null;
    };

    this.FormatBooleanBucketName = function (value) {
    	var toReturn = value;
        if (value == "NA" || value == "N/A" || value == "NULL" || value == "NOT AVAILABLE" || parseInt(value) == (-1)) {
            toReturn = "Not Available";
        } else if (value == "N" || value == "NO" || value == "FALSE" || value == "F" || parseInt(value) === (0)) {
            toReturn = "No";
        } else if (value == "Y" || value == "YES" || value == "TRUE" || value == "T" || parseInt(value) == (1)) {
            toReturn = "Yes";
        } 
        return toReturn;
    };
    
    this.GetAttributeBucketName = function (bucket, attributeMetadata) {
        if (bucket == null) {
            return "";
        }
        var toReturn = null;
        var lowerValue;
        var upperValue;
        if (bucket.Values != null && bucket.Values.length > 0) {
            // This is the Null bucket
            if (bucket.Values[0] == null) {
                toReturn = ResourceUtility.getString("ANALYTIC_ATTRIBUTE_NULL_VALUE_LABEL");
            } else {
                if (attributeMetadata != null) {
                    var fundamentalType = attributeMetadata.FundamentalType != null ? attributeMetadata.FundamentalType.toUpperCase() : null;
                    if (fundamentalType == this.FundamentalType.Boolean) {
                        var value = bucket.Values[0].toString().toUpperCase();
                        toReturn = this.FormatBooleanBucketName(value);
                        return toReturn;
                    }
                }
                var discreteValueString = "";
                for (var i = 0; i < bucket.Values.length; i++) {
                    var bucketValue = this.FormatBucketValue(bucket.Values[i], attributeMetadata);
                    if (discreteValueString === "") {
                        discreteValueString = bucketValue;
                    } else {
                        discreteValueString += ", " + bucketValue;
                    }
                }
                toReturn = discreteValueString;
            }
        } else if (bucket.LowerInclusive != null && bucket.UpperExclusive != null) {

            if (attributeMetadata != null) {
                var dataType = attributeMetadata.DataType != null ? attributeMetadata.DataType.toUpperCase() : null;
                if (dataType == this.DataType.Int || dataType == this.DataType.Integer) {
                    toReturn = this.FormatIntegerBucket(bucket.LowerInclusive, bucket.UpperExclusive, attributeMetadata);
                } else {
                    lowerValue = this.FormatBucketValue(bucket.LowerInclusive, attributeMetadata);
                    upperValue = this.FormatBucketValue(bucket.UpperExclusive, attributeMetadata);
                    toReturn = ResourceUtility.getString("ANALYTIC_ATTRIBUTE_CONTINUOUS_BETWEEN_LABEL", [lowerValue, upperValue]);
                }
            } else {
                lowerValue = this.FormatBucketValue(bucket.LowerInclusive, attributeMetadata);
                upperValue = this.FormatBucketValue(bucket.UpperExclusive, attributeMetadata);
                toReturn = ResourceUtility.getString("ANALYTIC_ATTRIBUTE_CONTINUOUS_BETWEEN_LABEL", [lowerValue, upperValue]);
            }
        } else if (bucket.LowerInclusive == null && bucket.UpperExclusive == null) {
            toReturn = ResourceUtility.getString("ANALYTIC_ATTRIBUTE_ALL_VALUES_LABEL");
        } else if (bucket.LowerInclusive != null) {
            lowerValue = this.FormatBucketValue(bucket.LowerInclusive, attributeMetadata);
            toReturn = ResourceUtility.getString("ANALYTIC_ATTRIBUTE_GREATER_THAN_LABEL", [lowerValue]);
        } else {
            upperValue = this.FormatBucketValue(bucket.UpperExclusive, attributeMetadata);
            toReturn = ResourceUtility.getString("ANALYTIC_ATTRIBUTE_LESS_THAN_LABEL", [upperValue]);
        }
        return String(toReturn);
    };

    // ENG-6735:
    //  1) If the bucket spans one integer (e.g. lower is 0 and upper is 1), return lower
    //  2) Otherwise, decrement upper exclusive so that it is "inclusive"
    this.FormatIntegerBucket = function (lower, upper, attributeMetadata) {
        if (upper - lower <= 1) {
            return lower;
        }

        var lowerValue = this.FormatBucketValue(lower, attributeMetadata);
        var upperValue = this.FormatBucketValue(upper - 1, attributeMetadata);
        return ResourceUtility.getString("ANALYTIC_ATTRIBUTE_CONTINUOUS_BETWEEN_LABEL", [lowerValue, upperValue]);
    };

    this.AbbreviateNumber = function (realValue, fundamentalType) {
        var parsedValue = parseFloat(realValue);
        // If the parsedValue is NaN then we have a mismatch of types so just return the value
        if (isNaN(parsedValue)) {
            return realValue;
        }

        // If the value's fundamental type is 'year', do not round it.
        if (fundamentalType == this.FundamentalType.Year) {
            return parsedValue;
        }

        // If the value is less than 1 it should get 2 decimal places
        // If the value is less than 1,000 it should get 1 decimal place, but only if it had a decimal place to begin with
        // Anything greater than 1,000 will be handled by NumberUtil.AbbreviateLargeNumber
        var abbreviatedNumber;
        if (parsedValue === 0) {
            abbreviatedNumber = parsedValue;
        } else if (parsedValue < 1) {
            abbreviatedNumber = parsedValue.toFixed(2);
        } else if (parsedValue < 1000 && parsedValue % 1 !== 0) {
            abbreviatedNumber = parsedValue.toFixed(1);
        } else {
            abbreviatedNumber = NumberUtility.AbbreviateLargeNumber(parsedValue, 1);
        }
        return abbreviatedNumber;
    };

    this.IsPredictorBoolean = function (attributeMetadata) {
    	if (attributeMetadata == null) {
    		return false;
    	}
    	var fundamentalType = attributeMetadata.FundamentalType != null ? attributeMetadata.FundamentalType.toUpperCase() : null;
    	return fundamentalType == this.FundamentalType.Boolean;
    };
    
    this.FormatBucketValue = function (value, attributeMetadata) {
        if (value == null || attributeMetadata == null) {
            return value;
        }

        var fundamentalType = attributeMetadata.FundamentalType != null ? attributeMetadata.FundamentalType.toUpperCase() : null;
        // If the coming data has fundamental type specified, manipulate the value as required according to fundamental type.
        if (fundamentalType == this.FundamentalType.Year ||
		fundamentalType == this.FundamentalType.Currency ||
		fundamentalType == this.FundamentalType.Numeric ||
		fundamentalType == this.FundamentalType.Percent) {
            var abbreviatedNumber = this.AbbreviateNumber(value, fundamentalType);
            // Handle currency and percent
            if (fundamentalType == this.FundamentalType.Currency) {
                return ResourceUtility.getString("CURRENCY_SYMBOL") + abbreviatedNumber;
            } else if (fundamentalType == this.FundamentalType.Percent) {
                return abbreviatedNumber + "%";
            } else {
                return abbreviatedNumber;
            }
        }

        var toReturn;
        var dataType = attributeMetadata.DataType != null ? attributeMetadata.DataType.toUpperCase() : null;
        switch (dataType) {
            // Format Numbers         
            case this.DataType.Double:
            case this.DataType.Int:
            case this.DataType.Integer:
            case this.DataType.Short:
            case this.DataType.Long:
            case this.DataType.Float:
                toReturn = this.AbbreviateNumber(value, fundamentalType);
                break;
            // Format Date         
            case this.DataType.Date:
                toReturn = DateTimeFormatUtility.FormatStringDate(value, false);
                break;
            // Format DateTime and Time         
            case this.DataType.DateTime:
            case this.DataType.Time:
                toReturn = DateTimeFormatUtility.FormatStringDate(value, true);
                break;
            // Format Boolean and Bit         
            case this.DataType.Boolean:
            case this.DataType.Bit:
                toReturn = this.FormatBooleanValueForDisplay(value);
                break;
            // Format EpochTime         
            case this.DataType.Epoch:
                toReturn = DateTimeFormatUtility.FormatEpochDate(value);
                break;
            default:
                //No formatting required for String or LongString
                toReturn = value;
                break;
        }

        return toReturn;
    };

    this.SortAttributeList = function (groomedAttributeList, descending) {
        var self = this;
        if (groomedAttributeList == null || groomedAttributeList.length === 0) {
            return groomedAttributeList;
        }

        if (descending === false) {
            groomedAttributeList.sort(function (a, b) {
                if (a.Lift - b.Lift < 0) {
                    return -1;
                }
                if (a.Lift - b.Lift === 0) {
                    return 0;
                }
                if (a.Lift - b.Lift > 0) {
                    return 1;
                }
                return 0;
            });
        } else {
            groomedAttributeList.sort(function (a, b) {
                if (b.Lift - a.Lift < 0) {
                    return -1;
                }
                if (b.Lift - a.Lift === 0) {
                    return 0;
                }
                if (b.Lift - a.Lift > 0) {
                    return 1;
                }
                return 0;
            });
        }

        return groomedAttributeList;
    };

    this.FormatLift = function (rawLift) {
        if (rawLift == null || typeof rawLift !== 'number') {
            return null;
        }

        if (rawLift === 0) {
            return "0";
        }

        return rawLift.toFixed(1);
    };

    this.ShouldShowNullBucket = function (bucket, nullThreshold) {
        var self = this;
        if (bucket == null) {
            return false;
        }
        nullThreshold = nullThreshold != null ? parseFloat(nullThreshold) : 100;

        // Discrete and Continuous null bucket
        if (bucket.Values != null && bucket.Values.length > 0) {
            for (var i = 0; i < bucket.Values.length; i++) {
                if (bucket.Values[i] == null && bucket.Lift <= nullThreshold) {
                    return false;
                }
            }
        }

        return true;
    };

    this.ShowBasedOnTags = function (widgetConfig, attributeMetadata) {
        if (widgetConfig == null || attributeMetadata == null) {
            return false;
        }

        //TODO:pierce This is a hack because DataLoader is not providing internal metadata
        if (attributeMetadata.Tags == null) {
            attributeMetadata.Tags = [];
        }

        // Check RequiredTags first
        var hasAllRequired = true;
        if (widgetConfig.RequiredTags != null) {
            for (var i = 0; i < widgetConfig.RequiredTags.length; i++) {
                var requiredTag = widgetConfig.RequiredTags[i];
                var hasRequired = false;
                for (var x = 0; x < attributeMetadata.Tags.length; x++) {
                    if (requiredTag == attributeMetadata.Tags[x]) {
                        hasRequired = true;
                        break;
                    }
                }

                if (!hasRequired) {
                    hasAllRequired = false;
                    break;
                }
            }
        }

        //Then check ExcludedTags
        var hasExcluded = false;
        if (widgetConfig.ExcludedTags != null) {
            for (var y = 0; y < widgetConfig.ExcludedTags.length; y++) {
                var excludedTag = widgetConfig.ExcludedTags[y];
                for (var z = 0; z < attributeMetadata.Tags.length; z++) {
                    if (excludedTag == attributeMetadata.Tags[z]) {
                        hasExcluded = true;
                        break;
                    }
                }
            }
        }

        if (hasExcluded) {
            return false;
        } else if (widgetConfig.RequiredTags != null && !hasAllRequired) {
            return false;
        } else {
            return true;
        }
    };

    this.IsApprovedForUsage = function (usage, attributeMetadata) {
        if (usage == null || attributeMetadata == null || attributeMetadata.ApprovedUsage == null) {
            return false;
        }

        for (var i = 0; i < attributeMetadata.ApprovedUsage.length; i++) {
            if (attributeMetadata.ApprovedUsage[i] == usage) {
                return true;
            }
        }

        return false;
    };

    //TODO:pierce Another hack because DataLoader is not properly populating the metadata
    this.IsAllowedForInsights = function (attributeMetadata) {
        if (attributeMetadata == null) {
            return false;
        } else if (attributeMetadata.ApprovedUsage == null || attributeMetadata.ApprovedUsage.length === 0) {
            return true;
        } else {
            return this.IsApprovedForUsage(this.ApprovedUsage.ModelAndAllInsights, attributeMetadata) === true ||
                this.IsApprovedForUsage(this.ApprovedUsage.ModelAndModelInsights, attributeMetadata) === true;
        }
    };

    this.FormatBooleanValueForDisplay = function (booleanValue) {
        if (booleanValue === null || booleanValue === "" || booleanValue === undefined) {
            return "";
        }
        if (typeof booleanValue === "boolean" || typeof booleanValue === "number") {
            booleanValue = booleanValue.toString();
        }
        booleanValue = booleanValue.toUpperCase();
        if (booleanValue == "1" || booleanValue === "TRUE") {
            return ResourceUtility.getString("BOOLEAN_TRUE_DISPLAY_LABEL");
        } else if (booleanValue == "0" || booleanValue === "FALSE") {
            return ResourceUtility.getString("BOOLEAN_FALSE_DISPLAY_LABEL");
        } else {
            return "";
        }
    };

    this.GetAttributeList = function (groomedPositiveAttributeList, groomedNegativeAttributeList, attributeLimit, score) {
        var groomedAttributeList = [];
        if (groomedPositiveAttributeList.length + groomedNegativeAttributeList.length <= attributeLimit) {
            return groomedPositiveAttributeList.concat(groomedNegativeAttributeList);
        }
        if (score >= 80) {
            return this.PopulateGroomedAttributeList(groomedPositiveAttributeList, groomedNegativeAttributeList, attributeLimit, 5);
        }
        if (score >= 60) {
            return this.PopulateGroomedAttributeList(groomedPositiveAttributeList, groomedNegativeAttributeList, attributeLimit, 4);
        }
        if (score >= 40) {
            return this.PopulateGroomedAttributeList(groomedPositiveAttributeList, groomedNegativeAttributeList, attributeLimit, 3);
        }
        return this.PopulateGroomedAttributeList(groomedPositiveAttributeList, groomedNegativeAttributeList, attributeLimit, 0);
    };

    this.PopulateGroomedAttributeList = function (groomedPositiveAttributeList, groomedNegativeAttributeList, attributeLimit, positiveAttributeCount) {
        var groomedAttributeList = [];
        if (attributeLimit < positiveAttributeCount) {
            return groomedAttributeList;
        }

        if (groomedPositiveAttributeList.length <= positiveAttributeCount) {
            groomedAttributeList = groomedPositiveAttributeList;
            var posAttrListLen = groomedPositiveAttributeList.length;
            for (var i = 0; i < attributeLimit - posAttrListLen && i < groomedNegativeAttributeList.length; i++) {
                groomedAttributeList.push(groomedNegativeAttributeList[i]);
            }
        } else {
            if (groomedNegativeAttributeList.length < attributeLimit - positiveAttributeCount) {
                positiveAttributeCount = Math.min(attributeLimit - groomedNegativeAttributeList.length, groomedPositiveAttributeList.length);
            }
            for (var j = 0; j < positiveAttributeCount; j++) {
                groomedAttributeList.push(groomedPositiveAttributeList[j]);
            }
            for (var k = 0; k < attributeLimit - positiveAttributeCount; k++) {
                groomedAttributeList.push(groomedNegativeAttributeList[k]);
            }
        }
        return groomedAttributeList;
    };

    this.GetLeadCount = function (modelSummary) {
        return modelSummary.Summary.DLEventTableData.SourceRowCount;
    };

});
angular.module('mainApp.appCommon.utilities.AnimationUtility', [])
.service('AnimationUtility', function () {
   
   this.CalculateRgbBetweenValues = function (highColor, lowColor, scalor)  {
        if (highColor == null || lowColor == null || scalor == null || scalor < 0) {
            return null;
        }
        if (scalor > 1) {
            scalor = scalor / 100;
        }
        
        var diffRed = scalor * highColor.R + (1-scalor) * lowColor.R;
        var diffGreen = scalor * highColor.G + (1-scalor) * lowColor.G;
        var diffBlue = scalor * highColor.B + (1-scalor) * lowColor.B;
        
        diffRed = Math.round(diffRed);
        diffGreen = Math.round(diffGreen);
        diffBlue = Math.round(diffBlue);
        
        return {
            R: diffRed,
            G: diffGreen,
            B: diffBlue
        };
    };
    
    this.ConvertSingleRgbToHex = function (c) {
        if (c == null) {
            return null;
        }
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    };
    
    this.ConvertRgbToHex = function (r, g, b) {
        if (r == null || g == null || b == null) {
            return null;
        }
        return "#" + this.ConvertSingleRgbToHex(r) + this.ConvertSingleRgbToHex(g) + this.ConvertSingleRgbToHex(b);
    };
    
});
angular.module('mainApp.appCommon.utilities.AuthenticationUtility', [
    'mainApp.appCommon.utilities.URLUtility'
])
.service('AuthenticationUtility', function (URLUtility) {
    
    this.AppendHttpHeaders = function ($http) {
        if ($http == null) {
            return;
        }
        //Default timeout
        $http.defaults.timeout = 120000;
        
        var type = URLUtility.GetSSOType();
        switch (type) {
            case URLUtility.SALESFORCE:
                if (URLUtility.Directory() != null) {
                    $http.defaults.headers.common.Directory = URLUtility.Directory();
                }
                $http.defaults.headers.common.sessionid = URLUtility.CrmSessionID();
                $http.defaults.headers.common.serverurl = URLUtility.CrmServerURL();
                $http.defaults.headers.common.userlink = URLUtility.CrmUser();
                break;

            case URLUtility.SAML:
                if (URLUtility.SamlDirectoryValue() != null) {
                    $http.defaults.headers.common.Directory = URLUtility.SamlDirectoryValue();
                }
                $http.defaults.headers.common.LESAMLUserLookup = URLUtility.SamlResponseValue();
                break;

            case URLUtility.LEA:
                if (URLUtility.Directory() != null) {
                    $http.defaults.headers.common.Directory = URLUtility.Directory();
                }
                $http.defaults.headers.common.LEAuthenticatedLookup = URLUtility.LeaResponse();
                break;
            case URLUtil.ORACLE:
                $http.defaults.headers.common.Directory = URLUtility.Directory();
                $http.defaults.headers.common.ssoToken = URLUtility.CrmSessionID();
                $http.defaults.headers.common.hostName = URLUtility.CrmServerURL();
                $http.defaults.headers.common.userlink = URLUtility.CrmUser();
                break;
        }
    };
});
angular.module('mainApp.appCommon.utilities.ConfigConstantUtility', [])
.service('ConfigConstantUtility', function () {
    // View Keys used for Navigation
    this.ViewAccount = "VIEW_ACCOUNT";
    this.ViewActionItems = "VIEW_ACTION_ITEMS";
    this.ViewAdmin = "VIEW_ADMIN";
    this.ViewBard = "VIEW_LEAD_SCORING";
    this.ViewMessages = "VIEW_INVITATION";
    this.ViewPlay = "VIEW_PLAY";
    this.ViewSales = "VIEW_SALES";
    this.ViewDashboardCenter = "VIEW_DASHBOARDCENTER";
    this.ViewChangePassword = "VIEW_CHANGE_PASSWORD";
    this.ViewProductHierarchy = "VIEW_PRODUCTHIERARCHY";

    // Hashes used for navigation
    // salesPRISM hashes
    this.ActionCenterHash = "#ActionCenter";
    this.SalesListHash = "#SalesList";
    this.PlayListHash = "#PlayList";
    this.LaunchMetricsHash = "#LaunchMetrics";
    this.LaunchRulesHash = "#LaunchRules";
    this.LaunchFiltersHash = "#LaunchFilters";
    this.PlayQuestionsHash = "#PlayQuestions";
    this.HoldoutsHash = "#Holdouts";
    this.ConfigConsoleHash = "#ConfigConsole";
    this.AdminConsoleHash = "#AdminConsole";
    this.UsersHash = "#Users";
    this.UserGroupsHash = "#UserGroups";
    this.AlertsHash = "#Alerts";
    this.PreviewAlertsHash = "#PreviewAlerts";
    this.FileTemplatesHash = "#FileTemplates";
    this.MailTemplatesHash = "#MailTemplates";
    this.FileUploadHash = "#FileUpload";
    this.ExternalDataHash = "#ExternalData";
    this.InvitationsHash = "#Invitations";
    this.ProductHierarchyHash = "#ProductHierarchy";

    // PLS hashes
    this.BardStatusHash = "#BardStatus";
    this.BardConfigHash = "#BardConfig";
    this.BardReportHash = "#BardReport";
    this.BardModelHash = "#BardModel";

    // Dante hashes
    this.DantePlayHash = "#DantePlays";
    this.DantePurchaseTrendsHash = "#DantePurchaseTrends";
    this.DanteCompanyDetailsHash = "#DanteCompanyDetails";
    this.DanteContactsHash = "#DanteContacts";


    // Right Keys used for Permission
    this.Play = "Play";
    this.ApprovePlay = "Approve_Play";

    // Currently Supported Error Code Descriptions
    this.DetailedDescriptionDataKey = "DetailedDescription";
    this.ImpersonationWriteError = "IMPERSONATION_WRITE_ERROR";
    this.ValidationInProgressError = "VALIDATION_ALREADY_IN_PROGRESS";
    this.ModelScoreErrorTargetFilterNoTargets = "MODELSCORE_TARGET_FILTERS_NO_ACCOUNTS";
    this.ModelScoreErrorTrainingFilterNoTargets = "MODELSCORE_TRAINING_FILTERS_NO_ACCOUNTS";

    // Online Help
    this.SalesHelp = "/Help/Sales_Help/index.html";
    this.PlayHelp = "/Help/PlayMaker_Help/index.html";
    this.AdminHelp = "/Help/Admin_Help/index.html";

    // ScoreSourceID
    this.ScoreSourceAnalytic = "Analytics";
    this.ScoreSourceUploaded = "Uploaded";
    this.ScoreSourceRuleBased = "RuleBased";
    this.ScoreSourceUnspecified = "Unspecified";

    // Field Length Validations
    this.StringShort = 150;
    this.StringInternalName = 50;
    // if we ever add maxRequestLength in web.config, please change this to match
    this.FileUploadMaxBytes = 4194304; // 4MB (default for .aspx)
    this.NumericFieldMaxLength = 9;
    this.MonetaryFieldMaxLength = 12;

    // PlayStage enum values
    this.PlayStageDetails = "Details";
    this.PlayStageTargets = "Targets";
    this.PlayStageRules = "Rules";
    this.PlayStageScore = "Score";
    this.PlayStageContent = "Content";
    this.PlayStageComplete = "Complete";

    // PlayScore enum values
    this.PlayScoreNone = "None";
    this.PlayScoreError = "Error";
    this.PlayScoreCanceled = "Canceled";
    this.PlayScoreProcessing = "Processing";
    this.PlayScoreComplete = "Complete";

    // Target Filter Relation values
    this.Contains = "CONTAINS";
    this.Equal = "EQUAL";
    this.GreaterThan = "GREATER_THAN";
    this.GreaterOrEqual = "GREATER_OR_EQUAL";
    this.LessThan = "LESS_THAN";
    this.LessOrEqual = "LESS_OR_EQUAL";
    this.GreaterThanSymbol = ">";
    this.GreaterOrEqualSymbol = "â‰¥";
    this.LessThanSymbol = "<";
    this.LessOrEqualSymbol = "â‰¤";
    this.NotEqual = "NOT_EQUAL";
    this.StartsWith = "STARTS_WITH";
    this.AfterNowOffsetMinutes = "AFTER_NOW_OFFSET_MINUTES";
    this.BeforeNowOffsetMinutes = "BEFORE_NOW_OFFSET_MINUTES";
    this.Ever = "EVER";
    this.Before = "BEFORE";
    this.After = "AFTER";
    this.Between = "BETWEEN";
    this.InCurrentPeriod = "IN_CURRENT_PERIOD";
    this.InSamePeriod = "IN_SAME_PERIOD";
    this.InNextPeriod = "IN_NEXT_PERIOD";
    this.Sum = "Sum";
    this.Each = "Each";
    this.AtLeastOnce = "AtLeastOnce";
    this.Average = "Average";
    this.HavePurchased = "HavePurchased";
    this.HaveNotPurchased = "HaveNotPurchased";
    this.Spent = "Spent";
    this.Units = "Units";
    this.Revenue = "Revenue";
    this.IsNull = "IS_NULL";
    this.IsNotNull = "IS_NOT_NULL";
    this.IsEmpty = "IS_EMPTY";
    this.IsNotEmpty = "IS_NOT_EMPTY";

    // Filter Target Type
    this.FilterTargetTypeStandard = "STANDARD";
    this.FilterTargetTypeProductPurchase = "PRODUCT_PURCHASE";

    // Filter Category Type
    this.FilterCategoryStatic = "STATIC";
    FilterCategoryTimesSeries = "TIMES_SERIES";

    // Target Build Type
    this.TargetBuildTypeNone = "None";
    this.TargetBuildTypeBuilder = "Builder";
    this.TargetBuildTypeUpload = "Upload";

    // Upload Algorithms
    this.UploadAccountAndProbabilityList = "UploadAccountAndProbabilityList";
    this.UploadAccountList = "UploadAccountList";
    this.UploadHoldoutList = "UploadHoldoutList";
    this.UploadPlayAccountProducts = "UploadPlayAccountProducts";

    // Upload Managers
    this.FileUploadManagerPlay = "PlayAccountList";
    this.FileUploadManagerPlayAccountProducts = "PlayAccountProducts";

    // TrainingBuildType
    this.TrainingBuildTypeCopyTargetFilter = "CopyTargetFilter";
    this.TrainingBuildTypeExplicitlyDefined = "ExplicitlyDefined";
    this.TrainingBuildTypeEmpty = "Empty";

    // EventBuildType
    this.EventBuildTypeExplicitlyDefined = "ExplicitlyDefined";
    EventBuildTypeDefaultFilter = "DefaultFilter";

    //Launch Rule Type
    this.PlaysWithExistingLeads = "PlaysWithExistingLeads";

    //Launch Destinations
    this.LeadLaunchDestination = {
        SalesPrism: "salesprism",
        Salesforce: "salesforce",
        SalesPrismAndCRM: "salesprism_and_CRM"
    };

    // Export Constants
    this.ExportPlayCustomerList = "PlayCustomerListExport";
    this.ExportPlayCustomerListContacts = "PlayCustomerListContactsExport";
    this.ExportPlayCustomerListWithContacts = "PlayCustomerListWithContactsExport";
    this.ExportHoldoutAccounts = "HoldoutAccountsExport";

    // PriorityType enum
    // These strings defines LikelihoodBuckets[i].ScoringMethodID.
    // And corresponds to LECore enum LeadScoringSourceType in PlayData.cs
    this.LikelihoodScoringMethodProbability = "Probability";
    this.LikelihoodScoringMethodLift = "Lift";
    this.LikelihoodScoringMethodManual = "Manual";
    this.LikelihoodScoringMethodNumValues = "NumValues";

    this.ScoringMethodSuffixLift = "x";
    this.ScoringMethodSuffixProbability = "%";

    // Model Health Score Categories =
    this.ModelHealthScoreExcellent = "EXCELLENT";
    this.ModelHealthScoreGood = "GOOD";
    this.ModelHealthScoreAverage = "AVERAGE";
    this.ModelHealthScoreError = "ERROR";

    this.ModelStatusActive = "Active";
    this.ModelStatusInactive = "Inactive";

    // ComplexFilterTypes:
    this.ComplexFilterType = {
        Training: "TRAINING",
        Target: "TARGET",
        Event: "EVENT",
        RuleBased: "RULE_BASED"
    };

    // Change Password service methods
    this.SalesprismChangePasswordMethod = "./WebLEApplicationServiceHost.svc/RegisterPendingLogAnchorIDs";
    this.SalesprismPasswordEncryptionType = "rsa";
    this.BardChangePasswordMethod = "./BardService.svc/ChangePassword";
    this.BardChangePasswordUponLoginMethod = "./LoginService.svc/ChangePasswordUponLogin";

    // Encryption algorthims
    this.SHA256 = "SHA-256";
    this.Base64 = "Base64";
    this.RSA = "rsa";

    // RSA public key
    this.rsa = {
        n: "BEB87612E3BBEFCFE80F58578A54D58DA46EB5B34D15D5F1B66F0C6040467D9910B434876F4730EAC92A9618C1B9B69CAFB3C4CA6ABC93ACEB018D8A8FA90E53301E6DA68A2D0E059654F0605769E60E7B366990AB55E65B7489C7A79A38F3CE0ECF26DF51401C16702D5811D354F1ED64B22919EFBE67332022C1AE75FDB5CFDE0CB45761AB9D26AFA301581CF06F76BF99CCF466B98836E6752E162FAEE550BE9ADCE5125063F9FAF37ECB5E206A830CE64B97A362260EF99582B4B1D3A3A2334261EDA281C112B478C32E609EDA9408BC3AD518F7F49C71236947D9F7677FD62655958349894AFD079595A7DC0D835A23D6F06A995C17EA254DE0961710B1",
        e: "10001"
    };

    // Corresponds to RuntimeEnums.cs: GeneralCRMInterfaceNames
    this.CrmType = {
        None: "None",
        Salesforce: "Salesforce",
        Siebel: "Siebel",
        Oracle: "Oracle"
    };
});
angular.module('mainApp.appCommon.utilities.DateTimeFormatUtility', [])
.service('DateTimeFormatUtility', function () {
   
    this.OneDayInMS = 86400000;
    /*
    * Formats date according to specified format type..
    * @param {jsonDate} date in JSON format "/Date(XXXXXXXXXX-XXXX)/".
    * @param {formatType} format to find in the list of formats.
    */
    this.FormatJsonDateCSharpFormat = function (jsonDate, formatType) {
        var datetime = this.ParseJsonDate(jsonDate);
        var dtformat = this.ConvertCSharpFormat(formatType);
        if (datetime == null || isNaN(datetime) || dtformat == null) {
            return "";
        }

        return dateFormat(new Date(datetime), dtformat);
    };

    /*
    * Formats date according to specified format type..
    * @param {jsonDate} date in JSON format "/Date(XXXXXXXXXX)/".
    * @param {formatType} format to find in the list of formats.
    */
    this.FormatCSharpDate = function (jsonDate, formatType) {
        var datetime = this.ConvertCSharpDateTimeOffsetToJSDate(jsonDate);
        var dtformat = this.ConvertCSharpFormat(formatType);
        if (datetime == null || isNaN(datetime) || dtformat == null) {
            return "";
        }

        return dateFormat(new Date(datetime), dtformat);
    };
    
    this.ConvertCSharpDateTimeOffsetToJSDate = function (csDate) {
        if (csDate == null || csDate.DateTime == null || csDate.OffsetMinutes == null) {
            return null;
        }
        //DateTime will look like "/Date(XXXXXXXXXX)/"
        var csDateTime = csDate.DateTime;
        var startParenIndex = csDateTime.indexOf("(");
        var endParenIndex = csDateTime.indexOf(")");
        if (startParenIndex === -1 || endParenIndex === -1) {
            return null;
        }

        var dateTimeInt = parseInt(csDateTime.substring(startParenIndex+1, endParenIndex));
        if (dateTimeInt == null || isNaN(dateTimeInt)) {
            return null;
        }
        
        return new Date(dateTimeInt);
    };
    
    this.CalculateDaysBetweenDates = function (startDate, endDate) {
        if (startDate == null || endDate == null) {
            return null;
        }
        
        var timeInMS = endDate.getTime() - startDate.getTime();
        
        return Math.floor(timeInMS / this.OneDayInMS);
    };

    /*
    * Extract and return date in milliseconds.
    * @param {jsonDate} date in JSON format "/Date(XXXXXXXXXX-XXXX)/".
    */
    this.ParseJsonDate = function (jsonDate) {
        // extract date portion
        var txt = $.trim(jsonDate);
        if (txt.length === 0) {
            return null;
        }
        var start = txt.indexOf("(");
        var end = txt.indexOf("-");
        if (start == -1 || end == -1 || start >= end) {
            return null;
        }
        var dt = txt.substring(start + 1, end);

        return Number(dt);
    };

    /*
     * Converts a JavaScript Date to the DateTimeOffset format that C# expects,
     * i.e.: for sending datetimeoffsets from the front end to the back end.
     * @param {jsDate}: Javascript Date object
     */
    this.ConvertJSDateToCSharpDateTimeOffset = function (jsDate, isEndDate) {
        if (!(jsDate instanceof Date)) {
            return jsDate;
        }

        // For an End Date, set its time to absolute latest
        // so that comparisons will also account for things on that day (DEF-5695)
        if (isEndDate === true) {
            jsDate.setHours(23, 59, 59, 999);
        } else if (isEndDate === false) { // Start Date - set its time to absolute earliest
            jsDate.setHours(0, 0, 0, 0);
        }

        var utcMsec = jsDate.getTime(); // milliseconds since 1970/01/01
        var cSharpDateTimeOffset = {
            DateTime: '/Date(' + utcMsec + ')/',
            OffsetMinutes : -1 * jsDate.getTimezoneOffset() // js does utc minus local, so need to negate
        };
        return cSharpDateTimeOffset;
    };

    /*
     * Convert a simple Date representation from C# (e.g. {Year:2013, Month:9, Day:1})
     * to a JavaScript Date object.
     */
    this.ConvertCSharpSimpleDateToJSDate = function (simpleDate) {
        var jsDate = new Date(
            simpleDate.Year,
            simpleDate.Month - 1, // JavaScript months go from 0-11
            simpleDate.Day
        );
        return jsDate;
    };

    /*
     * Converts minutes into an object with hours and minutes
     */
    this.MinutesToHoursAndMinutes = function (minutes) {
        if (isNaN(minutes)) {
            return null;
        }

        var toReturn = {};
        toReturn.Hours = parseInt(minutes / 60);
        toReturn.Minutes = (minutes % 60);
        return toReturn;
    };

    /*
    * Extract datetime format and converts it to the JavaScript format expected by date.format.js.
    * @param {formatType} format to find in the list of formats.
    */
    //TODO:pierce Whoever is using this needs to change the paramaters to not require BrowserStorage
    this.ConvertCSharpFormat = function (formatType, dateTimeFormatList) {

        // Bard has no getAppModelDoc, so return some default
        if (dateTimeFormatList == null) {
            return "m/d/yyyy h:MM tt Z";
        }
        
        var dateFormatValue = null;
        for (var i = 0; i < dateFormatList.length; i++) {
            if (dateFormatList[i].Key == formatType) {
                dateFormatValue = dateFormatList[i].Value;
                break;
            }
        }
        if (dateFormatValue == null || dateFormatValue.length === 0) {
            return null;
        }
        // replace all lower case 'm' with upper case 'M' to convert minutes format;
        // replace all 'M' to 'm' for month conversion;
        // replace 'z','zz','zzz' with single 'o'
        // replace 'K' with 'Z'
        var str = dateFormatValue.split('');

        for (i = 0; i < str.length; i++) {
            switch (str[i]) {
                case 'M': str[i] = 'm'; break;
                case 'm': str[i] = 'M'; break;
                case 'z':
                    str[i] = 'o';
                    // see if more than one z
                    for (var j = i + 1; j < str.length; j++) {
                        if (str[j] == 'z') {
                            str[j] = '';
                        }
                    }
                    break;
                case 'K': str[i] = 'Z'; break;
                default: break;
            }

        }
        dateFormatValue = str.join('');
        return dateFormatValue;
    };


    /* return right now in the format requested*/

    this.Now = function (formatType) {
    
        var dtformat = this.ConvertCSharpFormat(formatType);
        if(dtformat == null) {
            return "";
        }

        return dateFormat(new Date(), dtformat);
    };
    
    this.FormatStringDate = function(dateString, includeTime) {
        includeTime = includeTime != null && typeof includeTime === "boolean" ? includeTime : false;
        if (dateString == null || dateString === "") {
            return "";
        }
        
        var dateObj = new Date(dateString);
        if (dateObj == "Invalid Date") {
            return "";
        }
        
        if (includeTime) {
            return dateObj.toLocaleDateString() + " " + dateObj.toLocaleTimeString();
        } else {
            return dateObj.toLocaleDateString();
        }
    };
    
    this.FormatEpochDate = function (dateString) {
        if (dateString == null || dateString === "") {
            return "";
        }
        
        if(isNaN(dateString)) {
            return ""; 
        }
        
        var epochTime = parseInt(dateString) * 1000;
        var dateObj = new Date();
        dateObj.setTime(epochTime);
        
        return dateObj.toUTCString();
    };
    
    this.FormatShortDate = function (dateString) {
        return dateFormat(new Date(dateString), "m/d/yyyy");
    };
    
});
angular.module('mainApp.appCommon.utilities.EvergageUtility', [])                                                                                                                                                                        
.service('EvergageUtility', function () {
    // This will create a global variable used for Evergage tracking and 
    // add the Evergage tracking JavaScript
    this.Initialize = function (options) {
        if (options == null) {
            return;
        }
        var dataset = 'lp_multitenant_production';
        var evergageAccount = 'latticeengines';
        var userName = '';

        if (options.company != null) {
            userName += options.company + "-";
        }        
        
        // Add title if available
        if (options.title != null) {
            userName += options.title + "-";
        }
        
        if (options.userID != null) {
            userName += options.userID;
        } else {
            userName += Math.floor((Math.random()*1000)+1);
        }

        //TODO: entry point for Evergage user title story.
        // _aaq is created on the salesprism.aspx page so it becomes a global variable.
        // This is required by Evergage and has to be name _aaq.
        _aaq.push(['setEvergageAccount', evergageAccount], 
                  ['setDataset', dataset], 
                  ['setUseSiteConfig', true],
                  ['setUser', userName],
                  ['setCompany', options.company],
                  ['setAccountType', 'Standard'],
                  ['setLoggingLevel', 'NONE']);

        var d = document, g = d.createElement('script'), s = d.getElementsByTagName('script')[0];
        g.type = 'text/javascript'; g.defer = true; g.async = true;
        g.src = document.location.protocol + '//cdn.evergage.com/beacon/' +
                evergageAccount + '/' + dataset + '/scripts/evergage.min.js';
        s.parentNode.insertBefore(g, s);
    };
    
    // Determine if instance is Production, DEP or Development
    this.GetEnvironment = function (hostName) {
        var toReturn = "development";
        if (hostName == null) {
            return toReturn;
        }
        
        if (hostName.toLowerCase().indexOf("dep") !== -1) {
            toReturn = "deployment";
        } else if (hostName.toLowerCase().indexOf("lattice-engines") !== -1) {
            toReturn = "production";
        }

        return toReturn;
    };
    
    // Return the Deployment name from the URL pathname in window.location
    this.GetDeploymentName = function (pathname) {
        var toReturn = 'DEV';
        if (pathname != null) {
            var lastSlashIndex = pathname.lastIndexOf("/");
            if (lastSlashIndex > 0) {
                toReturn = pathname.substring(1, lastSlashIndex);
            } else {
                toReturn = pathname.substring(1);
            }
        }
        return toReturn;
    };
    
    this.TrackAction = function (actionName) {
        if (_aaq != null && actionName != null) {
            _aaq.push(['trackAction', actionName]);
        }
    };
});
angular.module('exceptionOverride', [
])
.factory('$exceptionHandler', function () {
    return function (exception, cause) {
      exception.message += ' (caused by "' + cause + '")';
      if (console != null) {
          console.log("Error: "+ exception.message);
      }
    };
  });
angular.module('mainApp.appCommon.utilities.FaultUtility', [
    'mainApp.appCommon.utilities.ConfigConstantUtility',
    'mainApp.appCommon.utilities.ResourceUtility',
    'mainApp.core.utilities.BrowserStorageUtility',
    'mainApp.appCommon.modals.SimpleModal'
])                                                                                                                                                                        
.service('FaultUtility', function (ResourceUtility, BrowserStorageUtility, SimpleModal) {
    
    this.HandleServiceResponseFailure = function (response, faultTitle, failSilently) {
        failSilently = typeof failSilently !== 'undefined' ? failSilently : false;
        //Session Timeout?
        if (this.HandleSessionTimeout(response)) return;
        //Authentication Issue?
        if (this.HandleAuthenticationIssue(response)) return;
        
        if (!failSilently) {
            //Special Error?
            if (this.HandleSpecialErrors(response)) return;
            
            //Generic Error
            var message = this.GenerateErrorMessage(response.Errors);
            this.ShowFaultAlert(message, faultTitle);
        }
    };
    
    //This is used to handle calls that get no response from the server (i.e. server is down)
    this.HandleNoResponseFailure = function (response, settings) {
        faultTitle = settings.faultTitle;
        failSilently = settings.failSilently;
        failSilently = typeof failSilently !== 'undefined' ? failSilently : false;
        if (!failSilently) {
            
            var message = this.GetWebServiceFaultDetails(response, settings);
            this.ShowFaultAlert(message, settings.faultTitle);
        }
    };
    
    /*
     * Checks for a session timeout error in the list of errors
     * 
     */
    this.HandleSessionTimeout = function (response) {
        var result = false;
        var timeoutString = ResourceUtility.getString('USER_SESSION_TIMEOUT');
        if (this.GetUserDisplayableErrors(response).indexOf(timeoutString) != -1) {  
            this.ShowFaultAlert(timeoutString, ResourceUtility.getString('USER_SESSION_TIMEOUT_TITLE'), this.ResetApp);
            result = true;
        }
        
        return result;
    };
    
    this.HandleAuthenticationIssue = function (response) {
        var result = false;
        var expiredString = ResourceUtility.getString('LOGIN_EXPIRED_AUTHENTICATION_CREDENTIALS');
        var invalidString = ResourceUtility.getString('LOGIN_INVALID_AUTHENTICATION_CREDENTIALS');
        if (this.GetUserDisplayableErrors(response).indexOf(expiredString) != -1) {
            this.ResetApp();
            result = true;
        } else if (this.GetUserDisplayableErrors(response).indexOf(invalidString) != -1) {
            this.ShowFaultAlert(invalidString, ResourceUtility.getString('INVALID_AUTHENTICATION_CREDENTIALS_TITLE'), this.ResetApp);
            result = true;
        }
        
        return result;
    };
    
    this.HandleSpecialErrors = function (response) {
        if (response != null && response.Errors != null && response.Errors.length > 0) {
            for (var x = 0; x<response.Errors.length;x++) {
                var error = response.Errors[x];
                if (error.CodeString == ConfigConstantUtility.ImpersonationWriteError) {
                    this.ShowFaultAlert(ResourceUtility.getString(error.CodeString));
                    return true;
                } else if (error.CodeString == ConfigConstantUtility.ValidationInProgressError) {
                    var detailedDescription = null;
                    for (var y = 0; y<error.DataList.length;y++) {
                        var errorDetail = error.DataList[y];
                        if (errorDetail == ResourceUtility.getString(ConfigConstantUtility.DetailedDescriptionDataKey)) {
                            detailedDescription = errorDetail;
                            //this should only break out of the $.each() loop and not out of HandleSpecialErrors
                            break;
                        }
                    }
                    if (detailedDescription == null) {
                        detailedDescription = ResourceUtility.getString(error.CodeString);
                    }
                    this.ShowFaultAlert(detailedDescription, error.Message);
                    return true;
                }
            }
        }
        return false;
    };
    
    this.GetUserDisplayableErrors = function (response) {
        var result = "";
        
        if (response != null && response.Errors != null && response.Errors.length > 0) {
            for (var x = 0; x<response.Errors.length;x++) {
                var errorValue = response.Errors[x];
                var errorMessage = errorValue.Message;
                var fullErrorMessage = errorMessage.replace(errorValue.CodeString, ResourceUtility.getString(errorValue.CodeString));
                if (errorMessage === fullErrorMessage) {
                    result += ResourceUtility.getString(errorValue.CodeString) + " " + fullErrorMessage + " ";
                } else {
                    result += fullErrorMessage + " ";
                }
            }
        }
        
        return result;
    };
    
    this.GetWebServiceFaultDetails = function (response, settings) {
        var result = "";
        //Handle special faults
        switch (response.statusText) {
            case "timeout":
                var timeoutString = ResourceUtility.getString('REQUEST_TIMEOUT_BEGIN');
                var timeoutInSeconds = settings.timeout / 1000;
                var unitString = settings.timeout != 1000 ? ResourceUtility.getString('REQUEST_TIMEOUT_SECONDS') : ResourceUtility.getString('REQUEST_TIMEOUT_SECOND');
                if (timeoutString !== 'REQUEST_TIMEOUT_BEGIN') {
                    result = timeoutString + " " + timeoutInSeconds + " " + unitString + ".";
                } else {
                    unitString = " second" + (settings.timeout != 1000 ? "s." : ".");
                    result = "Request timed out after " + settings.timeout + unitString;
                }
                break;
        }
        if (result === "") {
            var message = ResourceUtility.getString('SERVER_UNAVAILABLE') != 'SERVER_UNAVAILABLE' ? 
                ResourceUtility.getString('SERVER_UNAVAILABLE') : 'Server temporarily unavailable. Please retry later.';  
            result = message;
            if(response.status !== 0) {
                result += "<br /><br />Status Code: " + response.status;
                //Report error to New Relic
                var loc = settings.url.indexOf('?');
                NewRelicWorker.SendActivity("Error: " + response.status + " " + settings.url.substring(0, loc), 1);
            }
            if(response.statusText != null) {
                result += "<br /><br />Fault Detail: " + response.statusText;
            }
        }
        return result;
    };
    
    this.GenerateErrorMessage = function (errors) {
        var toReturn = "";
        if(!$.isEmptyObject(errors)) {
            for(var x = 0; x<errors.length;x++) {
                var parentError = errors[x];
                var numChildErrors = 0;
                if(!$.isEmptyObject(parentError.InnerErrors)) {
                    numChildErrors = parentError.InnerErrors.length;
                }
                
                if (numChildErrors === 0 || (numChildErrors > 0 && parentError.CodeString != "VALIDATION_ERROR")) {
                    toReturn += this.GenerateSingleErrorMessage(parentError, (numChildErrors > 0));
                }
                
                if (numChildErrors > 0)
                {
                    toReturn += this.GenerateErrorMessage(parentError.InnerErrors);
                }
            }
        }
        return toReturn;
    };
    
    this.GenerateSingleErrorMessage = function (error, isParent) {
        isParent = typeof isParent !== 'undefined' ? isParent : false;
        if (!isParent) {
            return "ERROR: " + ResourceUtility.getString(error.CodeString) +"<br /><br />" + error.Message + "<br /><br /><br />";
        }
        return "PARENT ERROR: " + ResourceUtility.getString(error.CodeString) +"<br /><br />" + error.Message + "<br /><br /><br />";
    };
    
    this.ShowFaultAlert = function (faultMessage, faultTitle, callback) {
        SimpleModal.show({
            message: faultMessage, 
            title: faultTitle, 
            okCallback: callback
        });
    };
    
    this.ResetApp = function () {
        BrowserStorageUtility.clear(false);
        ResourceUtility.clearResourceStrings();
        window.location.hash = "/Initial";
    };
    
     //This is used to handle failures returned from our own rest calls and handle them without throwing a pop up
    this.HandleFriendlyServiceResponseErrors = function (response) {
        if (response == null) {
            return;
        }
        //Session Timeout?
        if (this.HandleSessionTimeout(response)) return;
        //Authentication Issue?
        if (this.HandleAuthenticationIssue(response)) return;
        
        return this.GenerateErrorMessage(response.Errors);
    };
});
angular.module('mainApp.appCommon.utilities.MetadataUtility', [
    'mainApp.appCommon.utilities.SortUtility'
])
.service('MetadataUtility', function (SortUtility) {
    
    //Constants
    this.PropertyType = {
        INTEGER: "Int",
        INTEGER64: "Int64",
        DECIMAL: "Decimal",
        DOUBLE: "Double",
        BOOL: "Bool",
        STRING: "String",
        DATE_TIME_OFFSET: "DateTimeOffset",
        CURRENCY: "Currency",
        PROBABILITY: "Probability",
        PERCENTAGE: "Percentage",
        EPOCH_TIME: "EpochTime"
    };
    
    this.ApplicationContext = {
        Account: "LatticeForAccounts",
        Lead: "LatticeForLeads"
    };
    
    this.NotionNames = {
        Lead: "DanteLead"
    };
    
    this.GetNotionMetadata = function (notionName, metadata) {
        if (metadata == null || metadata.Notions == null || metadata.Notions.length === 0 || notionName == null || notionName === "") {
            return null;
        }
        for (var i = 0; i < metadata.Notions.length; i++) {
            var notion = metadata.Notions[i];
            if (notionName == notion.Key) {
                return notion.Value;
            }
        }
        return null;
    };
    
    this.GetNotionAssociationMetadata = function (notionName, associationNotionName, rootMetadata) {
        if (rootMetadata == null || notionName == null || associationNotionName == null || associationNotionName === "") {
            return null;
        }
        
        var metadata = this.GetNotionMetadata(notionName, rootMetadata);
        
        if (metadata == null || metadata.Associations == null) {
            return null;
        }
        
        for (var i = 0; i < metadata.Associations.length; i++) {
            var metadataAssociation = metadata.Associations[i];
            if (associationNotionName == metadataAssociation.TargetNotion) {
                return metadataAssociation;
            }
            
        }
        return null;
    };
    
    // Must pass in the relevant metadata object in order to get the correct property
    // e.g. Must pass in the DanteLead notion to get it's Name property
    this.GetNotionProperty = function (propertyName, notionMetadata) {
        if (notionMetadata == null || notionMetadata.Properties == null ||
            propertyName == null || propertyName === "") {
            return null;
        }

        for (var i = 0; i < notionMetadata.Properties.length; i++) {
            var metadataProperty = notionMetadata.Properties[i];
            if (propertyName == metadataProperty.Name) {
                return metadataProperty;
            }
            
        }
        return null;
    };

    this.GetCompareFunction = function (propertyTypeString) {
        switch (propertyTypeString) {
            // If you need to use custom compare functions 
            // for certain types (MetadataConstants.PropertyType),
            // put the cases here: 
            default:
                return SortUtility.DefaultCompare;
        }
    };
});
angular.module('mainApp.appCommon.utilities.NumberUtility', [])
.service('NumberUtility', function () {
   
    /*
        Purpose:        Given a number, will return the abbreviated version (e.g. 14000 becomes 14k)
        Parameters:     an integer
        Returns:        A string
    */
    this.AbbreviateLargeNumber = function (number, decPlaces) {
        if (number == null || typeof number != "number") {
            return null;
        }
        
        decPlaces = decPlaces != null && typeof decPlaces === 'number' ? decPlaces : 2;
        
        //Method acquired from: http://stackoverflow.com/questions/2685911/is-there-a-way-to-round-numbers-into-a-reader-friendly-format-e-g-1-1k
        
        // 2 decimal places => 100, 3 => 1000, etc
        decPlaces = Math.pow(10,decPlaces);

        // Enumerate number abbreviations
        var abbrev = [ "K", "M", "B", "T" ];
    
        // Go through the array backwards, so we do the largest first
        for (var i=abbrev.length-1; i>=0; i--) {
    
            // Convert array index to "1000", "1000000", etc
            var size = Math.pow(10,(i+1)*3);
    
            // If the number is bigger or equal do the abbreviation
            if(size <= number) {
                 // Here, we multiply by decPlaces, round, and then divide by decPlaces.
                 // This gives us nice rounding to a particular decimal place.
                 number = Math.round(number*decPlaces/size)/decPlaces;
    
                 // Handle special case where we round up to the next abbreviation
                 if((number == 1000) && (i < abbrev.length - 1)) {
                     number = 1;
                     i++;
                 }
    
                 // Add the letter for the abbreviation
                 number += abbrev[i];
    
                 // We are done... stop
                 break;
            }
        }
    
        return number;
    };
    
});
angular.module('mainApp.appCommon.utilities.ResourceUtility', [])                                                                                                                                                                        
.service('ResourceUtility', function () {
    
    this.DefaultLocale = "en-US";
    
    // key for config resource string object in local storage
    this.configStringsStorageKey = "ConfigStrings";
    this.configStringsKeyValueStorageKey = "ConfigStringKeyValues";
    this.configStringsLocaleStorageKey = "ConfigStringsLocale";

    // in memory dictionary of config resource string keys and values
    this.configStrings = null;
    
    // Indicator that somebody accessed the app without going through the proper channel
    this.resourceStringsInitialized = false;

    //This is needed for Flex so it can create it's StringLocator instance
    this.keyValuePairs = [];

    // get a config resource string value given its key
    this.getString = function (key, replacements) {
        if (this.configStrings == null) {
            this.populateConfigStrings();
        }
        var toReturn = this.configStrings[key] || key;
        if (replacements) {
            toReturn = this.replaceTokens(toReturn, replacements);
        }
        return toReturn;
    };
    
    this.clearResourceStrings = function () {
        $.jStorage.set(this.configStringsStorageKey, null);
        $.jStorage.set(this.configStringsKeyValueStorageKey, null);
        $.jStorage.set(this.configStringsLocaleStorageKey, null);
    };
    
    this.getResourceStrings = function () {
        return $.jStorage.get(this.configStringsStorageKey);
    };
    
    this.getResourceStringKeyValues = function () {
        return $.jStorage.get(this.configStringsKeyValueStorageKey);
    };
    
    this.setCurrentLocale = function (localeName) {
        $.jStorage.set(this.configStringsLocaleStorageKey, localeName);
    };
    
    this.getCurrentLocale = function () {
        return $.jStorage.get(this.configStringsLocaleStorageKey);
    };

    this.replaceTokens = function (key, replacements) {
        for (var i = 0; i < replacements.length; i++) {
            while (key.indexOf("{" + i + "}") != -1) {
                key = key.replace("{"+i+"}", replacements[i]);
            }
        }
        return key;
    };
    // populate in memory config resource strings dictionary from local storage
    this.populateConfigStrings = function () {
        var configStringsFromStorage = $.jStorage.get(
            this.configStringsStorageKey);

        this.configStrings = configStringsFromStorage || {};
    };

    // store a list of config resource string objects in local storage
    // set the config resource strings, e.g. if updating a subset for another locale
    // data should be a list of objects with "key" and a "value" properties
    this.storeStringList = function (stringList, successHandler) {
        //check if there is already anything in memory
        if (this.configStrings == null) {
            this.populateConfigStrings();
        }

        if (stringList != null) {
            for (var i = 0; i < stringList.length; i++) {
                var curPair = stringList[i];
                var curKey = curPair.Key;
                var curValue = curPair.Value;

                this.keyValuePairs.push(curPair);
                this.configStrings[curKey] = curValue;
            }
            this.resourceStringsInitialized = true;
        }

        // store updated set of strings back into local storage
        $.jStorage.set(this.configStringsStorageKey,
            this.configStrings);
            
        $.jStorage.set(this.configStringsKeyValueStorageKey,
            this.keyValuePairs);

        $(document).trigger('configStringsLoadedEvent');

        if (successHandler != null) {
            successHandler();
        }
    };

    //Preloads an image and return the preloaded image object
    this.PreloadImage = function (el, callback) {
        var img = new Image();
        img.onload = function () {
            callback(img);
        };
        img.src = el.attr("src");
    };

    this.SetBrowserTitle = function () {
        document.title = this.getString("BROWSER_TITLE");
    };
});
angular.module('mainApp.appCommon.utilities.SortUtility', [])                                                                                                                                                                        
.service('SortUtility', function () {
    
    // Sort a list of objects on multiple object properties
    // Each object in propsToSortOn should be something like:
    // { Name: "Quantity", IsAscending: true, CompareFunction: compareNumeric }
    this.MultiSort = function (objsToSort, propsToSortOn) {
        if (!(objsToSort instanceof Array)) {
            return;
        }

        if (objsToSort.length <= 0) {
            return;
        }

        var firstObj = objsToSort[0];
        var objType = typeof firstObj;
        // Just use default Array.sort for non-objects
        if (objType === "boolean" ||
            objType === "number" ||
            objType === "string") {
            objsToSort.sort();
        } else { // Sort objects using the properties to sort on
            var compareFunction = this.GetCompareFunction(propsToSortOn);
            if (typeof compareFunction === "function") {
                objsToSort.sort(compareFunction);
            }
        }
    };

    this.GetCompareFunction = function (propsToSortOn) {
        var self = this;

        // undefined means we don't know how to sort this
        var compareFunction;

        if (propsToSortOn instanceof Array &&
            propsToSortOn.length > 0) {

            compareFunction = function (a, b) {
                // compare a and b on each property
                // until you find one where they don't match
                for (var i = 0; i < propsToSortOn.length; i++) {
                    var prop = propsToSortOn[i];
                    var propName = prop.Name;
                    var propIsAscending = prop.IsAscending;
                    if (typeof propIsAscending !== "boolean") {
                        propIsAscending = true;
                    }
                    var propCompareFunction = prop.CompareFunction;

                    var compareResult = self.CompareObjectsByProperty(
                        a, b, propName, propIsAscending, propCompareFunction);
                    if (compareResult !== 0) {
                        return compareResult;
                    }
                }
                // a and b matched on all properties
                return 0;
            };

        }
        return compareFunction;
    };

    this.CompareObjectsByProperty = function (a, b, propName, propIsAscending, propCompareFunction) {

        var result = 0;

        if (a == null && b == null) {
            result = 0;
        } else if (a == null) {
            result = -1;
        } else if (b == null) {
            result = 1;
        } else {
            var propA = a[propName];
            var propB = b[propName];

            var compareFunction;
            if (typeof propCompareFunction === "function") {
                compareFunction = propCompareFunction;
            } else {
                compareFunction = this.DefaultCompare;
            }

            result = compareFunction(propA, propB);
        }
        return (propIsAscending ? result : -1 * result);
    };

    this.DefaultCompare = function (a, b) {
        if (a < b) {
            return -1;
        }
        if (a == b) {
            return 0;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    };

    // true comes before false
    this.ReverseBooleanCompare = function (a, b) {
        if ((typeof a !== "boolean") || (typeof b !== "boolean")) {
            return 0;
        }
        if (a === b) {
            return 0;
        }
        if (a === false) { // b is true
            return 1;
        }
        if (a === true) { // b is false
            return -1;
        }
    };
});
angular.module('mainApp.appCommon.utilities.StringUtility', [])                                                                                                                                                                        
.service('StringUtility', function () {

    this.IsEmptyString = function (stringToCheck) {
        var isEmpty = true;
        if (stringToCheck != null && stringToCheck.trim() !== "") {
            isEmpty = false;
        }
        return isEmpty;
    };
    
    this.AddCommas = function (stringToChange) {
        if (stringToChange == null) {
            return null;
        }
        var parts = stringToChange.toString().split(".");
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return parts.join(".");
    };
    
});
angular.module('mainApp.appCommon.utilities.TenantIdParsingUtility', [])
.service('TenantIdParsingUtility', function() {
    this.getDataLoaderTenantNameFromTenantId = function(tenantId) {
        tenantNameArray = tenantId.split("\.");
        if (tenantNameArray.length == 3) {
            return tenantNameArray[1];
        }
        return tenantNameArray[0];
    };
});
angular.module('mainApp.appCommon.utilities.TimestampIntervalUtility', [])
.service('TimestampIntervalUtility', function() {
    this.isTimestampFartherThanNinetyDaysAgo = function(timestamp) {
        if (!timestamp) {
            return false;
        }
        var MILLISECOND_PER_DAY = 24 * 60 * 60 * 1000;
        var numDaysAgoPasswordLastModified = Math.floor((Date.now() - timestamp) / MILLISECOND_PER_DAY) ;
        return numDaysAgoPasswordLastModified >= 90;
    };
});
angular.module('mainApp.appCommon.utilities.TrackingConstantsUtility', [
])
.service('TrackingConstantsUtility', function () {
    
    // Play Tracking actions
    this.PLAY_TAB_CLICKED = 'PlayTabClicked';
    this.PLAY_LIST_TILE_CLICKED = 'PlayListTileClicked';
    this.PLAY_DETAIL_TILE_CLICKED = 'PlayDetailTileClicked';
    this.TALKING_POINT_EXPANDED = 'TalkingPointExpanded';
    this.TALKING_POINT_COLLAPSED = 'TalkingPointCollapsed';
    
    // Company Snapshot actions
    this.COMPANY_SNAPSHOT_TAB_CLICKED = 'CompanySnapshotTabClicked';
});
angular.module('mainApp.appCommon.utilities.URLUtility', [
    'mainApp.appCommon.utilities.ConfigConstantUtility'
])
.service('URLUtility', function () {
    /**
    * Returns the location of the web server based on the main page
    */
    this.GetWebServerAddress = function (mainPage) {
        if (mainPage == null) {
            return null;
        }
        var pathname = location.pathname;
        var pageIndex = pathname.indexOf(mainPage);

        if (pageIndex != -1) {
            pathname = pathname.substring(0, pageIndex);
        }
        else {
            pathname = pathname.substring(0, pathname.length - 1);
        }

        return location.protocol + "//" + location.host + pathname;
    };
    
    this.GetBaseUrl = function () {
        return location.protocol + "//" + location.host + location.pathname;
    };
    
    this.GetUrlQueryStrings = function (url) {
        if (url == null) {
            return "";
        }
        var result = "";

        //First remove the hash if it is found
        var hashIndex = url.indexOf("#");
        if (hashIndex != -1) {
            url = url.substring(0, hashIndex);
        }

        //Find the beginning of the query string and remove everything before it
        var qIndex = url.indexOf("?");
        if (qIndex != -1) {
            result = url.substring(qIndex, url.length);
        }
        return result;
    };
    
    this.GetUrlWithQueryStrings = function (baseUrl) {
        if (baseUrl == null) {
            return null;
        }
        var url = this.HandleProtocol(baseUrl);
        var queryStringParameters = this.GetUrlQueryStrings(window.location.href);
        if (queryStringParameters != null && queryStringParameters != "?") {
            url += queryStringParameters;
        }
        return url;
    };

    this.RemoveQueryStringParameter = function (url, parameter) {
        var urlHash = "";
        var hashIndex = url.indexOf("#");
        var qIndex = url.indexOf('?');

        if (hashIndex > -1) {
            if (hashIndex < qIndex) {
                // hash is before the query string parameters
                urlHash = url.substring(hashIndex, qIndex);
            } else {
                // hash is at the end
                urlHash = url.substring(hashIndex);
                url = url.replace(urlHash, "");
            }
        }

        var urlparts = url.split('?');

        if (urlparts.length >= 2) {
            var prefix = encodeURIComponent(parameter) + '=';
            var pars = urlparts[1].split(/[&;]/g);
            for (var i = pars.length; i-- > 0; )               // reverse iteration as may be destructive
                if (pars[i].lastIndexOf(prefix, 0) !== -1)   // idiom for string.startsWith
                    pars.splice(i, 1);
            if (pars.length === 0) {
                url = urlparts[0];
            } else {
                url = urlparts[0] + '?' + pars.join('&');
            }
        }

        if (hashIndex > -1 && hashIndex < qIndex) {
            return url;
        } else {
            return url + urlHash;
        }
    };

    this.GetSalesPrismWebServerAddress = function (salesPrismURL) {
        if (salesPrismURL == null) {
            return null;
        }

        return this.HandleProtocol(salesPrismURL.replace(/\/salesprism.aspx/gi, ""));
    };

    this.GetSalesPrismMainPageAddress = function (salesPrismURL) {
        if (salesPrismURL == null) {
            return null;
        }
        var hasPage = salesPrismURL.indexOf("salesprism.aspx") !== -1;
        if (hasPage) {
            return this.HandleProtocol(salesPrismURL);
        }
        if (salesPrismURL.charAt(salesPrismURL.length - 1) === "/") {
            salesPrismURL += "salesprism.aspx";
        } else {
            salesPrismURL += "/salesprism.aspx";
        }

        return this.HandleProtocol(salesPrismURL);
    };

    this.GetBardWebServerAddress = function (bardUrl) {
        if (bardUrl == null) {
            return null;
        }

        return this.HandleProtocol(bardUrl.replace(/\/index.aspx/gi, ""));
    };

    this.GetBardMainPageAddress = function (bardUrl) {
        if (bardUrl == null) {
            return null;
        }
        var hasPage = bardUrl.indexOf("index.aspx") !== -1;
        if (hasPage) {
            return this.HandleProtocol(bardUrl);
        }
        if (bardUrl.charAt(bardUrl.length - 1) === "/") {
            bardUrl += "index.aspx";
        } else {
            bardUrl += "/index.aspx";
        }

        return this.HandleProtocol(bardUrl);
    };

    this.GetBardMainPageAddressWithHash = function (bardUrl) {
        if (bardUrl == null) {
            return null;
        }
        var currentLocation = window.location.href;
        var urlHash = "";
        var hashIndex = currentLocation.indexOf("#");
        var qIndex = currentLocation.indexOf('?');

        if (hashIndex > -1) {
            if (hashIndex < qIndex) {
                // hash is before the query string parameters
                urlHash = currentLocation.substring(hashIndex, qIndex);
            } else {
                // hash is at the end
                urlHash = currentLocation.substring(hashIndex);
            }
        }
        return this.GetBardMainPageAddress(bardUrl) + urlHash;
    };

    this.OpenWindow = function (url, location) {
        if (url == null || location == null) {
            return;
        }
        window.open(url, location);
    };

    this.OpenNewWindow = function (url) {
        this.OpenWindow(url, '_blank');
    };

    this.OpenPostWindow = function (target, url, data, fetchType) {
        var content = this.ConstructPostContent(url, data, fetchType);
        var win = window.open("about:blank", target);
        if (win) {
            win.document.write(content);
        }

        return win;
    };

    this.OpenPostIframe = function (target, url, data, fetchType) {
        var content = this.ConstructPostContent(url, data, fetchType);
        $("#" + target).html(content);
    };

    this.ConstructPostContent = function (url, data, fetchType) {
        fetchType = typeof fetchType !== 'undefined' ? fetchType : 'POST';
        var content = "<!DOCTYPE html><html><head></head><body>";
        content += "<form id=\"postForm\" method='" + fetchType + "' action='" + url + "'>";
        $.each(data, function (name, value) {
            content += "<input type='hidden' name='" + name + "' value='" + value + "'></input>";
        });
        content += "</form>";
        content += "<script type='text/javascript'>document.getElementById(\"postForm\").submit();</script>";
        content += "</body></html>";

        return content;
    };

    this.GetQueryStringValue = function (key, keepHash) {
        keepHash = typeof keepHash === 'boolean' ? keepHash : false;
        var result = null;
        var payload = window.location.href;
        var qIndex = payload.indexOf("?");
        if (qIndex != -1) {
            var queryString = payload.substring(qIndex + 1);

            var pair = null;
            var params = queryString.split("&");
            for (i = 0; i < params.length; i++) {

                pair = params[i].split("=");

                if (pair.length == 2 && pair[0] == key) {
                    result = pair[1];
                    break;
                }
            }
        }

        //cleanup: if the result contains a hash "#"
        //remove the hash and anything after
        if (result != null && !keepHash) {
            var hashIndex = result.indexOf("#");
            if (hashIndex != -1) {
                result = result.substring(0, hashIndex);
            }
        }

        return (result != null ? this.Decode(result) : null);
    };

    this.Decode = function (value) {
        var result = value;

        var matches = result.match(new RegExp("%..", "gi"));
        if (matches != null) {
            for (i = 0; i < matches.length; i++) {
                var charCode = parseInt("0x" + matches[i].substring(1));
                var character = String.fromCharCode(charCode);
                result = result.replace(matches[i], character);
            }
        }

        return result;
    };

    this.ExtractTabFromHash = function (hash) {
        var toReturn = null;
        switch (hash) {
            case ConfigConstantUtility.BardModelHash:
            case ConfigConstantUtility.BardStatusHash:
            case ConfigConstantUtility.BardConfigHash:
            case ConfigConstantUtility.BardReportHash:
                toReturn = ConfigConstantUtility.ViewBard;
                break;
            case ConfigConstantUtility.ActionCenterHash:
                toReturn = ConfigConstantUtility.ViewActionItems;
                break;
            case ConfigConstantUtility.SalesListHash:
                toReturn = ConfigConstantUtility.ViewSales;
                break;
            case ConfigConstantUtility.PlayListHash:
            case ConfigConstantUtility.LaunchMetricsHash:
            case ConfigConstantUtility.LaunchRulesHash:
            case ConfigConstantUtility.LaunchFiltersHash:
            case ConfigConstantUtility.PlayQuestionsHash:
            case ConfigConstantUtility.HoldoutsHash:
                toReturn = ConfigConstantUtility.ViewPlay;
                break;
            case ConfigConstantUtility.ConfigConsoleHash:
            case ConfigConstantUtility.AdminConsoleHash:
            case ConfigConstantUtility.UsersHash:
            case ConfigConstantUtility.UserGroupsHash:
            case ConfigConstantUtility.AlertsHash:
            case ConfigConstantUtility.PreviewAlertsHash:
            case ConfigConstantUtility.FileTemplatesHash:
            case ConfigConstantUtility.MailTemplatesHash:
            case ConfigConstantUtility.FileUploadHash:
            case ConfigConstantUtility.ExternalDataHash:
                toReturn = ConfigConstantUtility.ViewAdmin;
                break;
            case ConfigConstantUtility.InvitationsHash:
                toReturn = ConfigConstantUtility.ViewMessages;
                break;
            case ConfigConstantUtility.DashboardCenterHash:
                toReturn = ConfigConstantUtility.ViewDashboardCenter;
                break;
            case ConfigConstantUtility.ChangePasswordHash:
                toReturn = ConfigConstantUtility.ViewChangePassword;
                break;
            case ConfigConstantUtility.ProductHierarchyHash:
                toReturn = ConfigConstantUtility.ViewProductHierarchy;
                break;
            // Dante hashes     
            case ConfigConstantUtility.DantePlayHash:
                toReturn = ConfigConstantUtility.DantePlayHash;
                break;
            case ConfigConstantUtility.DantePurchaseTrendsHash:
                toReturn = ConfigConstantUtility.DantePurchaseTrendsHash;
                break;
            case ConfigConstantUtility.DanteCompanyDetailsHash:
                toReturn = ConfigConstantUtility.DanteCompanyDetailsHash;
                break;
            case ConfigConstantUtility.DanteContactsHash:
                toReturn = ConfigConstantUtility.DanteContactsHash;
                break;
        }

        return toReturn;
    };

    this.ExtractSubViewFromHash = function (hash) {
        var toReturn = null;

        switch (hash) {
            case ConfigConstantUtility.PlayListHash:
                toReturn = "Plays";
                break;
            case ConfigConstantUtility.LaunchMetricsHash:
                toReturn = "LaunchMetrics";
                break;
            case ConfigConstantUtility.LaunchRulesHash:
                toReturn = "LaunchRules";
                break;
            case ConfigConstantUtility.LaunchFiltersHash:
                toReturn = "FilterRules";
                break;
            case ConfigConstantUtility.PlayQuestionsHash:
                toReturn = "PlayQuestions";
                break;
            case ConfigConstantUtility.HoldoutsHash:
                toReturn = "UploadHoldouts";
                break;
            case ConfigConstantUtility.ConfigConsoleHash:
                toReturn = "ConfigConsole";
                break;
            case ConfigConstantUtility.AdminConsoleHash:
                toReturn = "AdminConsole";
                break;
            case ConfigConstantUtility.UsersHash:
                toReturn = "Users";
                break;
            case ConfigConstantUtility.UserGroupsHash:
                toReturn = "UserGroups";
                break;
            case ConfigConstantUtility.AlertsHash:
                toReturn = "Alerts";
                break;
            case ConfigConstantUtility.PreviewAlertsHash:
                toReturn = "PreviewAlerts";
                break;
            case ConfigConstantUtility.FileTemplatesHash:
                toReturn = "FeedTemplates";
                break;
            case ConfigConstantUtility.MailTemplatesHash:
                toReturn = "MailMerge";
                break;
            case ConfigConstantUtility.FileUploadHash:
                toReturn = "FileUpload";
                break;
            case ConfigConstantUtility.ExternalDataHash:
                toReturn = "ExternalData";
                break;
            case ConfigConstantUtility.BardStatusHash:
                toReturn = "BardStatus";
                break;
            case ConfigConstantUtility.BardConfigHash:
                toReturn = "BardConfig";
                break;
            case ConfigConstantUtility.BardReportHash:
                toReturn = "BardReport";
                break;
            case ConfigConstantUtility.BardModelHash:
                toReturn = "BardModel";
                break;
        }

        return toReturn;
    };

    this.HandleProtocol = function (url) {
        if (url == null) {
            return null;
        }
        var httpIncluded = url.indexOf("http://") === 0;
        var httpsIncluded = url.indexOf("https://") === 0;
        if (httpIncluded || httpsIncluded) {
            return url;
        } else {
            return location.protocol + "//" + url;
        }

    };

    /**
    * Query String/Navigator Property helpers 
    */

    //Different SSO query string parameters
    this.SALESFORCE = "salesforce";
    this.SAML = "saml";
    this.LEA = "lea";
    this.ORACLE = "oracle";

    this.Directory = function () {
        return this.GetQueryStringValue("Directory");
    };

    this.SamlResponseValue = function () {
        return this.GetQueryStringValue("LESAMLUserLookup");
    };

    this.SamlDirectoryValue = function () {
        return this.GetQueryStringValue("LESAMLDirectoryKey");
    };

    this.LeaResponse = function () {
        return this.GetQueryStringValue("LEAuthenticatedLookup");
    };

    /**
    * @return Current SSO type, or null if not using SSO 
    */
    this.GetSSOType = function () {
        if (this.Directory() == this.ORACLE) {
            return this.ORACLE;
        } else if (this.CrmSessionID() != null && this.CrmServerURL() != null) {
            return this.SALESFORCE;
        } else if (this.SamlResponseValue() != null) {
            return this.SAML;
        } else if (this.LeaResponse() != null) {
            return this.LEA;
        } else {
            return null;
        }
    };

    this.CrmSessionID = function () {
        var secretSessionId = this.GetQueryStringValue("sin");
        if (secretSessionId != null) {
            return secretSessionId;
        }
        return this.GetQueryStringValue("sessionid");
    };

    this.CrmServerURL = function () {
        return this.GetQueryStringValue("serverurl");
    };

    this.CrmUser = function () {
        var result = null;

        var rawValue = this.GetQueryStringValue("userlink");
        if (rawValue != null) {
            var sIndex = rawValue.lastIndexOf("/");
            if (sIndex != -1) {
                result = rawValue.substring(sIndex + 1);
            } else {
                result = rawValue;
            }
        }

        // Strip last 3 case-encoding characters
        if (result != null && result.length > 15) {
            result = result.substr(0, 15);
        }

        return result;
    };

    this.CrmType = function () {
        var crmType = this.GetQueryStringValue("crmtype");
        crmType = crmType.toLowerCase();
        crmType = StringUtil.CapitalizeFirstLetter(crmType);
        var crmTypes = ConfigConstantUtility.CrmType;
        switch (crmType) {
            case crmTypes.None:
            case crmTypes.Salesforce:
            case crmTypes.Siebel:
            case crmTypes.Oracle:
                return crmType;
            default:
                return crmTypes.None;
        }
    };

    this.CrmAccount = function () {
        return this.GetQueryStringValue("Account");
    };
    
    this.CrmLead = function () {
        return this.GetQueryStringValue("Lead");
    };
    
    this.CrmContact = function () {
        return this.GetQueryStringValue("Contact");
    };
    
    this.CrmIntegrationServer = function () {
        var result = null;

        var rawValue = this.GetQueryStringValue("userlink");
        if (rawValue != null) {
            var sIndex = rawValue.lastIndexOf("/");
            if (sIndex != -1) result = rawValue.substring(0, sIndex);
        }

        return result;
    };

    this.IntegrationServer = function () {
        var result = null;

        if (this.CrmServerURL() != null)
            result = this.CrmIntegrationServer();

        return (result != null ? result : "");
    };

    // Get the external ID of the Application's Directory
    // e.g. "default", "development", "salesforce", "saml", ...
    // code is currently based on DirectoryHelper.as: GetDirectory()
    this.GetApplicationDirectory = function () {
        var result = this.Directory();
        if (result == null) {
            result = this.SamlDirectoryValue();
        }
        return result;
    };
});
angular.module('mainApp.appCommon.utilities.UnderscoreUtility', [
])
.factory('_', function() {
    return window._; // assumes underscore has already been loaded on the page
});
angular.module('mainApp.appCommon.utilities.WidgetConfigUtility', [
])
.service('WidgetConfigUtility', function () {

    // Constants:

    // Widget types
    this.ANALYTIC_ATTRIBUTE_LIST_WIDGET = 'AnalyticAttributeListWidget';
    this.ANALYTIC_ATTRIBUTE_TILE_WIDGET = 'AnalyticAttributeTileWidget';
    this.ARC_CHART_WIDGET = 'ArcChartWidget';
    this.COLLAPSIBLE_PANEL_WIDGET = 'CollapsiblePanelWidget';
    this.GRID_WIDGET = 'GridWidget';
    this.LEAD_DETAILS_TILE_WIDGET = 'LeadDetailsTileWidget';
    this.MODEL_DETAILS_WIDGET = 'ModelDetailsWidget';
    this.MODEL_LIST_TILE_WIDGET = 'ModelListTileWidget';
    this.MODEL_LIST_CREATION_HISTORY = 'ModelListCreationHistoryWidget';
    this.REPEATER_WIDGET = 'RepeaterWidget';
    this.PLAY_DETAILS_TILE_WIDGET = 'PlayDetailsTileWidget';
    this.PLAY_LIST_TILE_WIDGET = 'PlayListTileWidget';
    this.RICH_TEXT_WIDGET = 'RichTextWidget';
    this.SCREEN_WIDGET = 'ScreenWidget';
    this.SCREEN_HEADER_WIDGET = 'ScreenHeaderWidget';
    this.SIMPLE_GRID_WIDGET = 'SimpleGridWidget';
    this.SIMPLE_TAB_WIDGET = 'SimpleTabWidget';
    this.TALKING_POINT_WIDGET = 'TalkingPointWidget';
    this.TEST_WIDGET = 'TestWidget';
    this.TAB_WIDGET = 'TabWidget';
    this.THRESHOLD_EXPLORER_WIDGET = 'ThresholdExplorerWidget';
    this.TOP_PREDICTOR_WIDGET = 'TopPredictorWidget';
    this.PERFORMANCE_TAB_WIDGET = 'PerformanceTabWidget';
    this.ADMIN_INFO_SUMMARY_WIDGET = 'AdminInfoSummaryWidget';
    this.ADMIN_INFO_ALERTS_WIDGET = 'AdminInfoAlertsWidget';
    this.LEADS_TAB_WIDGET = 'LeadsTabWidget';
    this.USER_MANAGEMENT_WIDGET = 'UserManagementWidget';
    this.MANAGE_FIELDS_WIDGET = 'ManageFieldsWidget';

    // Values for "ActiveWidgets" WidgetConfig property
    this.ACTIVE_WIDGET_ALL = "All";
    this.ACTIVE_WIDGET_EVEN = "Even";
    this.ACTIVE_WIDGET_FIRST = "First";
    this.ACTIVE_WIDGET_LAST = "Last";
    this.ACTIVE_WIDGET_NONE = "None";
    this.ACTIVE_WIDGET_ODD = "Odd";

    this.GetWidgetConfig = function (applicationWidgetConfig, id) {
        if (applicationWidgetConfig == null) {
            return null;
        }

        if (id == null || id === "") {
            return null;
        }

        if (applicationWidgetConfig.ID === id) {
            return applicationWidgetConfig;
        }

        // this widget is not a match and has no children to check
        if (applicationWidgetConfig.Widgets == null) {
            return null;
        }

        // check if any children match
        for (var i = 0; i < applicationWidgetConfig.Widgets.length; i++) {
            var child = applicationWidgetConfig.Widgets[i];
            var matchedChild = this.GetWidgetConfig(child, id);
            if (matchedChild !== null) {
                return matchedChild;
            }
        }

        return null;
    };
});
angular.module('mainApp.appCommon.services.ManageFieldsService', [
    'mainApp.appCommon.utilities.StringUtility',
    'mainApp.appCommon.utilities.ResourceUtility'
])
.service('ManageFieldsService', function (StringUtility, ResourceUtility) {

    this.GetOptionsForSelects = function (fields) {
        var allSources = [];
        var allCategories = [];
        var allOptions = [];
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if (!StringUtility.IsEmptyString(field.SourceToDisplay) && allSources.indexOf(field.SourceToDisplay) < 0) {
                allSources.push(field.SourceToDisplay);
            }
            if (!StringUtility.IsEmptyString(field.Category) && allCategories.indexOf(field.Category) < 0) {
                allCategories.push(field.Category);
            }

            var exist = false;
            for (var j = 0; j < allOptions.length; j++) {
                if (allOptions[j][0] == field.SourceToDisplay && allOptions[j][1] == field.Category) {
                    exist = true;
                    break;
                }
            }
            if (!exist) {
                allOptions.push([field.SourceToDisplay, field.Category]);
            }
        }

        var obj = {};
        obj.sourcesToSelect = allSources.sort();
        obj.categoriesToSelect = allCategories.sort();
        obj.allOptions = allOptions;
        return obj;
    };

    this.CategoryEditable = function (dataItem) {
        return (dataItem != null && dataItem.Tags != null && dataItem.Tags.toLowerCase() === "internal");
    };

});
angular.module('mainApp.appCommon.services.ModelAlertsService', [
    'mainApp.appCommon.utilities.StringUtility',
    'mainApp.appCommon.utilities.ResourceUtility'
])
.service('ModelAlertsService', function ($filter, StringUtility, ResourceUtility) {

    this.GetWarnings = function (modelAlerts, suppressedCategories) {
        var warnings = {};
        warnings.noWarning = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_NO_WARNING");
        warnings.modelQualityWarningsTitle = ResourceUtility.getString('ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_TITLE');
        warnings.modelQualityWarningsLabel = ResourceUtility.getString('ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_LABEL');
        warnings.missingMetaDataWarningsTitle = ResourceUtility.getString('ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_TITLE');
        warnings.missingMetaDataWarningsLabel = ResourceUtility.getString('ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_LABEL');

        // Get model quality warnings
        var modelQualityWarnings = [];
        var modelQualityWarningsObj = modelAlerts.ModelQualityWarnings;
        if (modelQualityWarningsObj != null) {
            addSuccessEventsWarning(modelQualityWarnings, modelQualityWarningsObj);
            addConversionRateWarning(modelQualityWarnings, modelQualityWarningsObj);
            addOutOfRangeRocScoreWarning(modelQualityWarnings, modelQualityWarningsObj);
            addExcessiveDiscreteValuesAttributesWarning(modelQualityWarnings, modelQualityWarningsObj);
            addExcessivePredictiveAttributesWarning(modelQualityWarnings, modelQualityWarningsObj);
            addExcessivePredictiveNullValuesAttributesWarning(modelQualityWarnings, modelQualityWarningsObj);
        }
        warnings.noModelQualityWarnings = (modelQualityWarnings.length === 0);
        warnings.modelQualityWarnings = modelQualityWarnings;

        // Get missing meta-data warnings
        var missingMetaDataWarnings = [];
        var missingMetaDataWarningsObj = modelAlerts.MissingMetaDataWarnings;
        if (missingMetaDataWarningsObj != null) {
            addInvalidApprovedUsageAttributesWarning(missingMetaDataWarnings, missingMetaDataWarningsObj);
            addInvalidTagsAttributesWarning(missingMetaDataWarnings, missingMetaDataWarningsObj);
            addInvalidCategoryAttributesWarning(missingMetaDataWarnings, missingMetaDataWarningsObj);
            addInvalidDisplayNameAttributesWarning(missingMetaDataWarnings, missingMetaDataWarningsObj);
            addInvalidStatisticalTypeAttributesWarning(missingMetaDataWarnings, missingMetaDataWarningsObj);
            addExcessiveCategoriesInModelSummaryWarning(missingMetaDataWarnings, suppressedCategories);
        }
        warnings.noMissingMetaDataWarnings = (missingMetaDataWarnings.length === 0);
        warnings.missingMetaDataWarnings = missingMetaDataWarnings;

        return warnings;
    };

    function addSuccessEventsWarning(warnings, modelQualityWarnings) {
        var successEvents = modelQualityWarnings.LowSuccessEvents;
        var minValue = modelQualityWarnings.MinSuccessEvents;
        if (successEvents != null && minValue != null) {
            var warning = {};
            successEvents = $filter('number')(successEvents, 0); // Add comma per 3 digits
            minValue = $filter('number')(minValue, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_SUCCESS_EVENTS_TOO_LOWER_TITLE", [successEvents, minValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ADJUST_FILTERS_EVENT_DEFINITION");
            warning.successEvents = successEvents; // For unit test
            warning.minValue = minValue;
            warnings.push(warning);
        }
    }

    function addConversionRateWarning(warnings, modelQualityWarnings) {
        var conversionPercentage = modelQualityWarnings.LowConversionPercentage;
        var minValue = modelQualityWarnings.MinConversionPercentage;
        if (conversionPercentage != null && minValue != null) {
            var warning = {};
            conversionPercentage = $filter('number')(conversionPercentage, 1);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_CONVERSION_RATE_TOO_LOWER_TITLE", [conversionPercentage, minValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ADJUST_FILTERS_EVENT_DEFINITION");
            warning.conversionPercentage = conversionPercentage;
            warning.minValue = minValue;
            warnings.push(warning);
        }
    }

    function addOutOfRangeRocScoreWarning(warnings, modelQualityWarnings) {
        var rocScore = modelQualityWarnings.OutOfRangeRocScore;
        var minValue = modelQualityWarnings.MinRocScore;
        var maxValue = modelQualityWarnings.MaxRocScore;
        if (rocScore != null && minValue != null && maxValue != null) {
            var warning = {};
            rocScore = $filter('number')(rocScore, 2);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ROC_SCORE_OUTSIDE_CREDIBLE_RANGE", [rocScore, minValue, maxValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ADJUST_FILTERS_EVENT_DEFINITION");
            warning.rocScore = rocScore;
            warning.minValue = minValue;
            warning.maxValue = maxValue;
            warnings.push(warning);
        }
    }

    function addExcessiveDiscreteValuesAttributesWarning(warnings, modelQualityWarnings) {
        var attributes = modelQualityWarnings.ExcessiveDiscreteValuesAttributes;
        var maxValue = modelQualityWarnings.MaxNumberOfDiscreteValues;
        if (attributes != null && attributes.length > 0 && maxValue != null) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            maxValue = $filter('number')(maxValue, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ATTRIBUTES_OVERLY_DISCRETE_VALUES_TITLE", [count, maxValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ATTRIBUTES_REMOVED_FROM_MODELING");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinStringList(attributes, 0);
            warning.count = count;
            warning.maxValue = maxValue;
            warnings.push(warning);
        }
    }

    function addExcessivePredictiveAttributesWarning(warnings, modelQualityWarnings) {
        var attributes = modelQualityWarnings.ExcessivePredictiveAttributes;
        var maxValue = modelQualityWarnings.MaxFeatureImportance;
        if (attributes != null && attributes.length > 0 && maxValue != null) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ATTRIBUTES_OVERLY_PREDICTIVE_TITLE", [count, maxValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ATTRIBUTES_CONTAIN_FUTURE_INFORMATION_REQUIRE_EM_JSUTIFICATION_VALID_PREDICTOR");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinMapList(attributes, 1);
            warning.count = count;
            warning.maxValue = maxValue;
            warnings.push(warning);
        }
    }

    function addExcessivePredictiveNullValuesAttributesWarning(warnings, modelQualityWarnings) {
        var attributes = modelQualityWarnings.ExcessivePredictiveNullValuesAttributes;
        var maxValue = modelQualityWarnings.MaxLiftForNull;
        if (attributes != null && attributes.length > 0 && maxValue != null) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ATTRIBUTES_HIGHLY_PREDICTIVE_NULL_VALUES", [count, maxValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MODEL_QUALITY_ATTRIBUTES_CONFIRM_ABSENCE_DATA_HAS_BUSINESS_MEANING");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinMapList(attributes, 1);
            warning.count = count;
            warning.maxValue = maxValue;
            warnings.push(warning);
        }
    }

    function addInvalidApprovedUsageAttributesWarning(warnings, missingMetaDataWarnings) {
        var attributes = missingMetaDataWarnings.InvalidApprovedUsageAttributes;
        if (attributes != null && attributes.length > 0) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_INVALID_APPROVED_USAGE", [count]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_SUPPRESSED_FROM_TOP_PREDICTORS_UI_CSV_BUYER_INSIGHTS");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinStringList(attributes);
            warning.count = count;
            warnings.push(warning);
        }
    }

    function addInvalidTagsAttributesWarning(warnings, missingMetaDataWarnings) {
        var attributes = missingMetaDataWarnings.InvalidTagsAttributes;
        if (attributes != null && attributes.length > 0) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_INVALID_TAGS", [count]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_SUPPRESSED_FROM_TOP_PREDICTORS_UI_CSV_BUYER_INSIGHTS");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinStringList(attributes);
            warning.count = count;
            warnings.push(warning);
        }
    }

    function addInvalidCategoryAttributesWarning(warnings, missingMetaDataWarnings) {
        var attributes = missingMetaDataWarnings.InvalidCategoryAttributes;
        if (attributes != null && attributes.length > 0) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_INVALID_CATEGORY", [count]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_SUPPRESSED_FROM_TOP_PREDICTORS_UI_CSV_BUYER_INSIGHTS");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinStringList(attributes);
            warning.count = count;
            warnings.push(warning);
        }
    }

    function addInvalidDisplayNameAttributesWarning(warnings, missingMetaDataWarnings) {
        var attributes = missingMetaDataWarnings.InvalidDisplayNameAttributes;
        if (attributes != null && attributes.length > 0) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_INVALID_DISPLAY_NAME", [count]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_SUPPRESSED_FROM_TOP_PREDICTORS_UI_CSV_BUYER_INSIGHTS");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinStringList(attributes);
            warning.count = count;
            warnings.push(warning);
        }
    }

    function addInvalidStatisticalTypeAttributesWarning(warnings, missingMetaDataWarnings) {
        var attributes = missingMetaDataWarnings.InvalidStatisticalTypeAttributes;
        if (attributes != null && attributes.length > 0) {
            var warning = {};
            var count = $filter('number')(attributes.length, 0);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_INVALID_STATISTICAL_TYPE", [count]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_ATTRIBUTES_BUCKETED_INCORRECTLY_IN_TOP_PREDICTORS_UI_CSV_BUYER_INSIGHTS");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_ATTRIBUTES");
            warning.impactedContent = joinStringList(attributes);
            warning.count = count;
            warnings.push(warning);
        }
    }

    function addExcessiveCategoriesInModelSummaryWarning(warnings, suppressedCategories) {
        var categories = suppressedCategories;
        //  We currently only show top 8 categories in the UI
        if (categories != null && categories.length > 0) {
            var warning = {};
            var count = $filter('number')(categories.length + 8, 0);
            var maxValue = 8;
            var categoryNames = getCategoryNames(categories);
            warning.title = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_MODEL_SUMMARY_CONTAINS_OVERLY_CATEFORIES", [count, maxValue]);
            warning.description = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_MISSING_META_DATA_TWO_CATEFORIES_AND_ATTRIBUTES_SUPPRESSED_FROM_TOP_PREDICTORS_UI");
            warning.impactedLabel = ResourceUtility.getString("ADMIN_INFO_ALERTS_PAGE_IMPACTED_CATEGORIES");
            warning.impactedContent = joinStringList(categoryNames);
            warning.count = count;
            warning.maxValue = maxValue;
            warnings.push(warning);
        }
    }

    function getCategoryNames(categories) {
        var categoryNames = [];
        if (categories == null) {
            return categoryNames;
        }
        for (var i = 0; i < categories.length; i++) {
            var category = categories[i];
            categoryNames.push(category.name);
        }
        return categoryNames;
    }

    function joinMapList(elements, fractionSize) {
        var content = "";
        var length = elements.length;
        for (var i = 0; i < length; i++) {
            var element = elements[i];
            var value = fractionSize != null ? $filter('number')(element.value, fractionSize) : element.value;
            content += element.key + " (" + value + ")";
            if (i + 1 < length) {
                content += ", ";
            }
        }

        return content;
    }

    function joinStringList(elements) {
        var content = "";
        var length = elements.length;
        for (var i = 0; i < length; i++) {
            content += elements[i];
            if (i + 1 < length) {
                content += ", ";
            }
        }

        return content;
    }

});
angular.module('mainApp.appCommon.services.ModelSummaryValidationService', [
    'mainApp.appCommon.utilities.ResourceUtility'
])
.service('ModelSummaryValidationService', function (ResourceUtility) {

    this.ValidateModelSummary = function (modelSummary) {
        var i, errors = [];

        if (!modelSummary) {
            errors.push(ResourceUtility.getString("VALIDATION_ERROR_MODEL_SUMMARY_MISSING"));
            return errors;
        }

        try {
            //Segmentations
            var segmentationErrors = ValidateSegmentations(modelSummary);
            if (segmentationErrors.length > 0) PushErrors(errors, segmentationErrors);

            //Predictors
            var predictorErrors = ValidatePredictors(modelSummary);
            if (predictorErrors.length > 0) PushErrors(errors, predictorErrors);

            //ModelDetails
            var detailErrors = ValidateModelDetails(modelSummary);
            if (detailErrors.length > 0) PushErrors(errors, detailErrors);

            //TopSample
            var topSampleErrors = ValidateTopSample(modelSummary);
            if (topSampleErrors.length > 0) PushErrors(errors, topSampleErrors);

            //BottomSample
            var bottomSampleErrors = ValidateBottomSample(modelSummary);
            if (bottomSampleErrors.length > 0) PushErrors(errors, bottomSampleErrors);

            //EventTableProvenance (Skip)

        } catch (exc) {
            errors.push(exc.message);
        }

        return errors;
    };

    function PushErrors(errors, newErrors) {
        for (var i = 0; i < newErrors.length; i++) {
            errors.push(newErrors[i]);
        }
    }

    function PushError(errors, key) {
        errors.push(ResourceUtility.getString(key));
    }

    function PushErrorWithOffset(errors, key, i) {
        errors.push(ResourceUtility.getString(key) + ErrorOffset(i));
    }

    function PushErrorWithOffsets(errors, key, i, j) {
        errors.push(ResourceUtility.getString(key) + ErrorOffsets(i, j));
    }

    function ErrorOffset(i) {
        return " [i = " + i + "]";
    }

    function ErrorOffsets(i, j) {
        return " [i = " + i + "]" + " [j = " + j + "]";
    }

    //==================================================
    // Segmentations
    //==================================================
    function ValidateSegmentations(modelSummary) {
        var i, segment, errors = [];

        if (!modelSummary.hasOwnProperty("Segmentations")) {
            PushError(errors, "VALIDATION_ERROR_SEGMENTATIONS_MISSING");
        } else if (!Array.isArray(modelSummary.Segmentations) || modelSummary.Segmentations.length != 1) {
            PushError(errors, "VALIDATION_ERROR_SEGMENTATIONS_UNEXPECTED");
        } else {
            var segmentation = modelSummary.Segmentations[0];

            //LeadSource (Skip)

            //Segments
            if (!segmentation.hasOwnProperty("Segments")) {
                PushError(errors, "VALIDATION_ERROR_SEGMENTS_MISSING");
            } else if (!Array.isArray(segmentation.Segments) || segmentation.Segments.length != 100) {
                PushError(errors, "VALIDATION_ERROR_SEGMENTS_UNEXPECTED");
            } else {
                for (i = 0; i < 100; i++) {
                    segment = segmentation.Segments[i];

                    //Score
                    if (!segment.hasOwnProperty("Score"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_SEGMENT_SCORE_MISSING", i);
                    else if (segment.Score != parseInt(segment.Score))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_SEGMENT_SCORE_INVALID", i);

                    //Count
                    if (!segment.hasOwnProperty("Count"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_SEGMENT_COUNT_MISSING", i);
                    else if (segment.Count != parseInt(segment.Count))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_SEGMENT_COUNT_INVALID", i);

                    //Converted
                    if (!segment.hasOwnProperty("Converted"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_SEGMENT_CONVERTED_MISSING", i);
                    else if (segment.Converted != parseInt(segment.Converted))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_SEGMENT_CONVERTED_INVALID", i);
                }
            }
        }

        return errors;
    }

    //==================================================
    // Predictors
    //==================================================
    function ValidatePredictors(modelSummary) {
        var i, j, predictor, errors = [];

        if (!modelSummary.hasOwnProperty("Predictors")) {
            PushError(errors, "VALIDATION_ERROR_PREDICTORS_MISSING");
        } else {
            var predictors = modelSummary.Predictors;
            if (!Array.isArray(predictors)) {
                PushError(errors, "VALIDATION_ERROR_PREDICTORS_UNEXPECTED");
            } else {
                for (i = 0; i < predictors.length; i++) {
                    predictor = predictors[i];

                    //Name
                    if (!predictor.hasOwnProperty("Name"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_NAME_MISSING", i);

                    //Tags
                    if (!predictor.hasOwnProperty("Tags"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_TAGS_MISSING", i);
                    else if (predictor.Tags != null && !Array.isArray(predictor.Tags))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_TAGS_UNEXPECTED", i);

                    //DataType
                    if (!predictor.hasOwnProperty("DataType"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_DATA_TYPE_MISSING", i);

                    //DisplayName
                    if (!predictor.hasOwnProperty("DisplayName"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_DISPLAY_NAME_MISSING", i);

                    //Description
                    if (!predictor.hasOwnProperty("Description"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_DESCRIPTION_MISSING", i);

                    //ApprovedUsage
                    if (!predictor.hasOwnProperty("ApprovedUsage"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_APPROVED_USAGE_MISSING", i);
                    else if (predictor.ApprovedUsage != null && !Array.isArray(predictor.ApprovedUsage))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_APPROVED_USAGE_UNEXPECTED", i);

                    //FundamentalType
                    if (!predictor.hasOwnProperty("FundamentalType"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_FUNDAMENTAL_TYPE_MISSING", i);

                    //Category
                    if (!predictor.hasOwnProperty("Category"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_CATEGORY_MISSING", i);

                    //UncertaintyCoefficient
                    if (!predictor.hasOwnProperty("UncertaintyCoefficient"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_UNCERTAINTY_COEFFICIENT_MISSING", i);
                    else if (predictor.UncertaintyCoefficient != parseFloat(predictor.UncertaintyCoefficient))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_UNCERTAINTY_COEFFICIENT_INVALID", i);

                    //Elements
                    if (!predictor.hasOwnProperty("Elements")) {
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENTS_MISSING", i);
                    } else if (!Array.isArray(predictor.Elements)) {
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENTS_UNEXPECTED", i);
                    } else {
                        for (j = 0; j < predictor.Elements.length; j++) {
                            var element = predictor.Elements[j];

                            //CorrelationSign
                            if (!element.hasOwnProperty("CorrelationSign"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_CORRELATION_SIGN_MISSING", i, j);
                            else if (!(element.CorrelationSign === -1 || element.CorrelationSign === 1))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_CORRELATION_SIGN_INVALID", i, j);

                            //Count
                            if (!element.hasOwnProperty("Count"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_COUNT_MISSING", i, j);
                            else if (element.Count != parseInt(element.Count))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_COUNT_INVALID", i, j);

                            //Lift
                            if (!element.hasOwnProperty("Lift"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_LIFT_MISSING", i, j);
                            else if (element.Lift != parseFloat(element.Lift))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_LIFT_INVALID", i, j);

                            //LowerInclusive
                            if (element.hasOwnProperty("LowerInclusive") &&
                                    element.LowerInclusive != null &&
                                    element.LowerInclusive != parseFloat(element.LowerInclusive))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_LOWER_INCLUSIVE_INVALID", i, j);

                            //UpperExclusive
                            if (element.hasOwnProperty("UpperExclusive") &&
                                    element.UpperExclusive != null &&
                                    element.UpperExclusive != parseFloat(element.UpperExclusive))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_UPPER_EXCLUSIVE_INVALID", i, j);

                            //Name
                            if (!element.hasOwnProperty("Name"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_NAME_MISSING", i, j);

                            //UncertaintyCoefficient
                            if (!element.hasOwnProperty("UncertaintyCoefficient"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_UNCERTAINTY_COEFFICIENT_MISSING", i, j);
                            else if (element.UncertaintyCoefficient != parseFloat(element.UncertaintyCoefficient))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_UNCERTAINTY_COEFFICIENT_INVALID", i, j);

                            //Values
                            if (!element.hasOwnProperty("Values"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_VALUES_MISSING", i, j);
                            else if (!Array.isArray(element.Values))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_VALUES_UNEXPECTED", i, j);

                            //IsVisible
                            if (!element.hasOwnProperty("IsVisible"))
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_IS_VISIBLE_MISSING", i, j);
                            else if (typeof element.IsVisible != "boolean")
                                PushErrorWithOffsets(errors, "VALIDATION_ERROR_PREDICTOR_ELEMENT_IS_VISIBLE_INVALID", i, j);
                        }
                    }
                }
            }
        }

        return errors;
    }

    //==================================================
    // ModelDetails
    //==================================================
    function ValidateModelDetails(modelSummary) {
        var errors = [];

        if (!modelSummary.hasOwnProperty("ModelDetails")) {
            PushError(errors, "VALIDATION_ERROR_MODEL_DETAILS_MISSING");
        } else {
            var details = modelSummary.ModelDetails;

            //Name
            if (!details.hasOwnProperty("Name"))
                PushError(errors, "VALIDATION_ERROR_MODEL_NAME_MISSING");

            //LookupID (Skip)

            //Total Leads
            if (!details.hasOwnProperty("TotalLeads"))
                PushError(errors, "VALIDATION_ERROR_TOTAL_LEADS_MISSING");
            else if (details.TotalLeads != parseInt(details.TotalLeads))
                PushError(errors, "VALIDATION_ERROR_TOTAL_LEADS_INVALID");

            //Testing Leads
            if (!details.hasOwnProperty("TestingLeads"))
                PushError(errors, "VALIDATION_ERROR_TESTING_LEADS_MISSING");
            else if (details.TestingLeads != parseInt(details.TestingLeads))
                PushError(errors, "VALIDATION_ERROR_TESTING_LEADS_INVALID");

            //Training Leads
            if (!details.hasOwnProperty("TrainingLeads"))
                PushError(errors, "VALIDATION_ERROR_TRAINING_LEADS_MISSING");
            else if (details.TrainingLeads != parseInt(details.TrainingLeads))
                PushError(errors, "VALIDATION_ERROR_TRAINING_LEADS_INVALID");

            //Total Conversions
            if (!details.hasOwnProperty("TotalConversions"))
                PushError(errors, "VALIDATION_ERROR_TOTAL_CONVERSIONS_MISSING");
            else if (details.TotalConversions != parseInt(details.TotalConversions))
                PushError(errors, "VALIDATION_ERROR_TOTAL_CONVERSIONS_INVALID");

            //Testing Conversions
            if (!details.hasOwnProperty("TestingConversions"))
                PushError(errors, "VALIDATION_ERROR_TESTING_CONVERSIONS_MISSING");
            else if (details.TestingConversions != parseInt(details.TestingConversions))
                PushError(errors, "VALIDATION_ERROR_TESTING_CONVERSIONS_INVALID");

            //Training Conversions
            if (!details.hasOwnProperty("TrainingConversions"))
                PushError(errors, "VALIDATION_ERROR_TRAINING_CONVERSIONS_MISSING");
            else if (details.TrainingConversions != parseInt(details.TrainingConversions))
                PushError(errors, "VALIDATION_ERROR_TRAINING_CONVERSIONS_INVALID");

            //ROC Score
            if (!details.hasOwnProperty("RocScore"))
                PushError(errors, "VALIDATION_ERROR_ROC_SCORE_MISSING");
            else if (details.RocScore != parseFloat(details.RocScore))
                PushError(errors, "VALIDATION_ERROR_ROC_SCORE_INVALID");

            //Construction Time
            if (!details.hasOwnProperty("ConstructionTime"))
                PushError(errors, "VALIDATION_ERROR_CONSTRUCTION_TIME_MISSING");
            else if (details.ConstructionTime != parseInt(details.ConstructionTime))
                PushError(errors, "VALIDATION_ERROR_CONSTRUCTION_TIME_INVALID");
        }

        return errors;
    }

    //==================================================
    // TopSample
    //==================================================
    function ValidateTopSample(modelSummary) {
        var i, errors = [];

        if (!modelSummary.hasOwnProperty("TopSample")) {
            PushError(errors, "VALIDATION_ERROR_TOP_SAMPLE_MISSING");
        } else {
            var topSample = modelSummary.TopSample;
            if (!Array.isArray(topSample)) {
                PushError(errors, "VALIDATION_ERROR_TOP_SAMPLE_UNEXPECTED");
            } else {
                for (i = 0; i < topSample.length; i++) {
                    sample = topSample[i];

                    //Company
                    if (!sample.hasOwnProperty("Company"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_COMPANY_MISSING", i);

                    //FirstName
                    if (!sample.hasOwnProperty("FirstName"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_FIRST_NAME_MISSING", i);

                    //LastName
                    if (!sample.hasOwnProperty("LastName"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_LAST_NAME_MISSING", i);

                    //Converted
                    if (!sample.hasOwnProperty("Converted"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_CONVERTED_MISSING", i);
                    else if (typeof sample.Converted != "boolean")
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_CONVERTED_INVALID", i);

                    //Score
                    if (!sample.hasOwnProperty("Score"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_SCORE_MISSING", i);
                    else if (sample.Score != parseInt(sample.Score))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_TOP_SAMPLE_SCORE_INVALID", i);
                }
            }
        }

        return errors;
    }

    //==================================================
    // BottomSample
    //==================================================
    function ValidateBottomSample(modelSummary) {
        var i, errors = [];

        if (!modelSummary.hasOwnProperty("BottomSample")) {
            PushError(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_MISSING");
        } else {
            var bottomSample = modelSummary.BottomSample;
            if (!Array.isArray(bottomSample)) {
                PushError(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_UNEXPECTED");
            } else {
                for (i = 0; i < bottomSample.length; i++) {
                    sample = bottomSample[i];

                    //Company
                    if (!sample.hasOwnProperty("Company"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_COMPANY_MISSING", i);

                    //FirstName
                    if (!sample.hasOwnProperty("FirstName"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_FIRST_NAME_MISSING", i);

                    //LastName
                    if (!sample.hasOwnProperty("LastName"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_LAST_NAME_MISSING", i);

                    //Converted
                    if (!sample.hasOwnProperty("Converted"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_CONVERTED_MISSING", i);
                    else if (typeof sample.Converted != "boolean")
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_CONVERTED_INVALID", i);

                    //Score
                    if (!sample.hasOwnProperty("Score"))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_SCORE_MISSING", i);
                    else if (sample.Score != parseInt(sample.Score))
                        PushErrorWithOffset(errors, "VALIDATION_ERROR_BOTTOM_SAMPLE_SCORE_INVALID", i);
                }
            }
        }

        return errors;
    }
});
angular.module('mainApp.appCommon.services.PlayTileService', [
    'mainApp.appCommon.utilities.ResourceUtility',
    'mainApp.appCommon.utilities.MetadataUtility',
    'mainApp.appCommon.utilities.DateTimeFormatUtility',
    'mainApp.appCommon.utilities.NumberUtility'
])
.service('PlayTileService', function (ResourceUtility, MetadataUtility, DateTimeFormatUtility, NumberUtility) {
    
    this.GetTileData = function (data, widgetConfig, metadata, successCallback) {
        if (data == null || widgetConfig == null || metadata == null) {
            return {};
        }
        
        var tileData = {
            ID: null,
            Name: "",
            Lift: null,
            LiftDisplayKey: null,
            ActiveDays: null,
            ActiveDaysDisplayKey: null,
            Revenue: null,
            RevenueDisplayKey: null,
            Objective: "",
            PlayType: "",
            IsActive: true,
            CrmId: null
        };

        // Find the appropriate notion metadata
        var notionMetadata = MetadataUtility.GetNotionMetadata(widgetConfig.Notion, metadata);
        
        // Find ID from the metadata
        var leadIdProperty = MetadataUtility.GetNotionProperty(widgetConfig.IdProperty, notionMetadata);
        if (leadIdProperty != null) {
            tileData.ID = data[leadIdProperty.Name] || null;
        }
        // Find Play Name from the metadata
        var nameProperty = MetadataUtility.GetNotionProperty(widgetConfig.NameProperty, notionMetadata);
        if (nameProperty != null && nameProperty.PropertyTypeString == MetadataUtility.PropertyType.STRING) {
            tileData.Name = data[nameProperty.Name] || "";
        }

        // Find Lift from the metadata
        var liftProperty = MetadataUtility.GetNotionProperty(widgetConfig.LiftProperty, notionMetadata);
        if (liftProperty != null && liftProperty.PropertyTypeString == MetadataUtility.PropertyType.DOUBLE) {
            tileData.Lift = data[liftProperty.Name] || null;
            if (tileData.Lift != null) {
                tileData.Lift = tileData.Lift.toPrecision(2);
                tileData.Lift += "x";
                tileData.LiftDisplayKey = ResourceUtility.getString(liftProperty.DisplayNameKey);
            }
        }

        // Find LaunchDate from the metadata
        var launchDateProperty = MetadataUtility.GetNotionProperty(widgetConfig.LaunchDateProperty, notionMetadata);
        if (launchDateProperty != null) {
            tileData.ActiveDaysDisplayKey = ResourceUtility.getString(launchDateProperty.DisplayNameKey);
            var launchDate = data[launchDateProperty.Name] || null;
            if (launchDate != null) {
                var dateObj;
                if (launchDateProperty.PropertyTypeString == MetadataUtility.PropertyType.DATE_TIME_OFFSET) {
                    dateObj = DateTimeFormatUtility.ConvertCSharpDateTimeOffsetToJSDate(launchDate);
                    tileData.ActiveDays = DateTimeFormatUtility.CalculateDaysBetweenDates(dateObj, new Date());
                } else if (launchDateProperty.PropertyTypeString == MetadataUtility.PropertyType.EPOCH_TIME) {
                    var epochTime = parseInt(launchDate) * 1000;
                    dateObj = new Date();
                    dateObj.setTime(epochTime);
                    tileData.ActiveDays = DateTimeFormatUtility.CalculateDaysBetweenDates(dateObj, new Date());
                }
            }
        }
        
        // Never show 0 for Days Active
        if (tileData.ActiveDays === 0) {
            tileData.ActiveDays = 1;
        }

        // Find Revenue from the metadata
        var revenueProperty = MetadataUtility.GetNotionProperty(widgetConfig.RevenueProperty, notionMetadata);
        if (revenueProperty != null && revenueProperty.PropertyTypeString == MetadataUtility.PropertyType.CURRENCY) {
            var revenueInt = data[revenueProperty.Name] || null;
            if (revenueInt != null) {
                tileData.Revenue = NumberUtility.AbbreviateLargeNumber(revenueInt);
                tileData.RevenueDisplayKey = ResourceUtility.getString(revenueProperty.DisplayNameKey);
            }
        }

        // Find the Objective from the metadata
        var objectiveProperty = MetadataUtility.GetNotionProperty(widgetConfig.ObjectiveProperty, notionMetadata);
        if (objectiveProperty != null && objectiveProperty.PropertyTypeString == MetadataUtility.PropertyType.STRING) {
            tileData.Objective = data[objectiveProperty.Name] || "";
            if (tileData.Objective.length > 140) {
                tileData.Objective = this.Objective.substring(0, 140) + "...";
            }
        }

        // Find the Play Type icon
        var playTypeProperty = MetadataUtility.GetNotionProperty(widgetConfig.PlayTypeProperty, notionMetadata);
        if (playTypeProperty != null) {
            tileData.PlayType = data[playTypeProperty.Name] || null;
        }
        
        // Check if the CRM Lead is active in the CRM system
        var salesforceIdProperty = MetadataUtility.GetNotionProperty(widgetConfig.CrmIdProperty, notionMetadata);
        if (salesforceIdProperty != null) {
            tileData.CrmId = data[salesforceIdProperty.Name];
            if (tileData.CrmId == null) {
                if (successCallback != null && typeof successCallback === "function") {
                    successCallback(tileData);
                }
            } else {
                var isActiveEvent = "IsLeadActiveEvent=" + tileData.CrmId;
                window.parent.postMessage(isActiveEvent, "*");
                
                
                window.addEventListener('message', function (evt) {
                    if (evt && evt.data.indexOf("IsLeadActiveReturnEvent="+tileData.CrmId) !== -1) {
                        var questionMarkIndex = evt.data.indexOf("?");
                        var isActiveQueryString = evt.data.substring(questionMarkIndex + 1, evt.data.length);
                        var separatorIndex = isActiveQueryString.indexOf("=");
                        var isActiveString = isActiveQueryString.substring(separatorIndex + 1, isActiveQueryString.length);
                        tileData.IsActive = isActiveString === "true" ? true : false;
                        
                        if (successCallback != null && typeof successCallback === "function") {
                            successCallback(tileData);
                        }
                    }
                });
            }
        } else {
            if (successCallback != null && typeof successCallback === "function") {
                successCallback(tileData);
            }
        } 
    };
});
angular.module('mainApp.appCommon.services.ThresholdExplorerService', [
    'mainApp.appCommon.utilities.ResourceUtility'
])
.service('ThresholdExplorerService', function (ResourceUtility) {

    this.PrepareData = function (modelSummary) {

        if (modelSummary == null ||
            modelSummary.ModelDetails == null ||
            modelSummary.Segmentations == null) {
            return {"ChartData": [], "DecileData": []};
        }

        var chartData = this.GetChartData(modelSummary);
        var decileData = this.GetDecileData(chartData);
        var liftData = this.GetLiftData(chartData);

        return {ChartData : chartData, DecileData: decileData, LiftData: liftData};
    };

    this.GetChartData = function (modelSummary) {
        var conversion;
        var i;
        //==================================================
        // Prepare
        //==================================================
        var totalLeads = modelSummary.ModelDetails.TestingLeads;
        var totalConversions = modelSummary.ModelDetails.TestingConversions;
        var avgConversion = totalConversions / totalLeads;

        var segments = modelSummary.Segmentations[0].Segments;

        var percentLeads = []; for (i = 0; i < 101; i++) percentLeads.push(i);

        var cumConversions = []; cumConversions.push(0);
        var cumCount = []; cumCount.push(0);
        for (i = 1; i < 101; i++) {
            cumConversions.push(cumConversions[i - 1] + segments[i - 1].Converted);
            cumCount.push(cumCount[i - 1] + segments[i - 1].Count);
        }

        var cumPctConversions = []; cumPctConversions.push(0);
        for (i = 1; i < 101; i++) {
            cumPctConversions.push(100 * (cumConversions[i] / totalConversions));
        }

        var leftLift = []; leftLift.push(0);
        for (i = 1; i < 101; i++) {
            conversion = cumConversions[i] / cumCount[i];
            leftLift.push(conversion / avgConversion);
        }

        var rightLift = [];
        for (i = 0; i < 100; i++) {
            conversion = (totalConversions - cumConversions[i]) / (totalLeads - cumCount[i]);
            rightLift.push(conversion / avgConversion);
        }
        rightLift.push(0);

        var score = []; score.push(0);
        for (i = 100; i > 0; i--) {
            score.push(i);
        }

        //==================================================
        // Load
        //==================================================
        var data = [];
        for (i = 0; i < 101; i++) {
            data.push({
                "leads": percentLeads[i],
                "score": score[i],
                "conversions": cumPctConversions[i],
                "leftLift": leftLift[i],
                "rightLift": rightLift[i]});
        }

        return data;
    };

    this.GetDecileData = function (chartData) {
        var result = [];
        for (var i = 1; i < 11; i++) {
            result.push(chartData[i * 10].conversions);
        }


        return result;
    };

    this.GetLiftData = function (chartData) {
        var result = [];
        for (var i = 1; i < 11; i++) {
            var bucket_conversion = chartData[i * 10].conversions - chartData[(i - 1) * 10].conversions;
            result.push(bucket_conversion / 10.0);
        }
        return result;
    };

    this.PrepareExportData = function (modelSummary) {
        var result = [];

        var chartData = modelSummary.hasOwnProperty("ThresholdChartData") ?
                        modelSummary.ThresholdChartData :
                        this.GetChartData(modelSummary);

        var segments = modelSummary.Segmentations[0].Segments;

        var columns = [
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_SCORE_LABEL"),
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_LEADS_LABEL"),
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_CONVERSIONS_LABEL"),
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_LEFT_LIFT_LABEL"),
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_RIGHT_LIFT_LABEL"),
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_COUNT_LABEL"),
            ResourceUtility.getString("MODEL_ADMIN_THRESHOLD_EXPORT_CONVERTED_LABEL")
        ];
        result.push(columns);

        for (var i = 1; i < 101; i++) {
            var row = [];
            row.push(chartData[i].score);
            row.push(chartData[i].leads + "%");
            row.push(chartData[i].conversions.toFixed(0) + "%");
            row.push(chartData[i].leftLift.toFixed(2));
            row.push(chartData[i].rightLift.toFixed(2));
            row.push(segments[i - 1].Count);
            row.push(segments[i - 1].Converted);
            result.push(row);
        }

        return result;
    };
});
angular.module('mainApp.appCommon.services.TopPredictorService', [
    'mainApp.appCommon.utilities.StringUtility',
    'mainApp.appCommon.utilities.AnalyticAttributeUtility',
    'mainApp.appCommon.utilities.ResourceUtility',
    'mainApp.appCommon.utilities.UnderscoreUtility'
])
.service('TopPredictorService', function (_, StringUtility, AnalyticAttributeUtility, ResourceUtility) {

    this.GetSuppressedCategories = function (modelSummary) {
        var categories = this.GetAllCategories(modelSummary);
        return this.SelectSuppressedCategories(modelSummary, categories);
    };

    this.GetTopCategories = function (modelSummary) {
        var categories = this.GetAllCategories(modelSummary);
        return this.SelectTopCategories(modelSummary, categories);
    };

    this.GetAllCategories = function (modelSummary) {
        if (modelSummary == null || modelSummary.Predictors == null || modelSummary.Predictors.length === 0) {
            return null;
        }

        // First sort all predictors by UncertaintyCoefficient
        modelSummary.Predictors = modelSummary.Predictors.sort(this.SortByPredictivePower);

        var categories = [];
        var categoryNames = [];
        var category;
        for (var i = 0; i < modelSummary.Predictors.length; i++) {
            var predictor = modelSummary.Predictors[i];
            if (AnalyticAttributeUtility.IsAllowedForInsights(predictor) &&
                this.PredictorHasValidBuckets(predictor, modelSummary.ModelDetails.TotalLeads) &&
                !StringUtility.IsEmptyString(predictor.Category) &&
                categoryNames.indexOf(predictor.Category) === -1) {
                categoryNames.push(predictor.Category);
                category = {
                    name: predictor.Category,
                    categoryName: predictor.Category,
                    UncertaintyCoefficient: predictor.UncertaintyCoefficient,
                    size: 1, // This doesn't matter because the inner ring takes on the size of the outer
                    color: null,
                    children: []
                };
                categories.push(category);
            }
        }
        return categories;
    };

    //=======================================================================
    // Top categories should be determined based on sum of predictive power
    // for top X attributes in a given category. Note: X is currently 3.
    //=======================================================================
    this.SelectTopCategories = function (modelSummary, categories) {
        var sortedCategories = this.SortCategoriesByPowerSumDescending(modelSummary, categories);
        var topCategories = sortedCategories;
        //Select Maximum of 8 Categories
        if (sortedCategories.length > 8) {
            topCategories = sortedCategories.slice(0, 8);
        }

        return topCategories;
    };

    this.SelectSuppressedCategories = function (modelSummary, categories) {
        var sortedCategories = this.SortCategoriesByPowerSumDescending(modelSummary, categories);
        var suppressedCategories = null;
        //Select Categories Except for The Top 8
        if (sortedCategories.length > 8) {
            suppressedCategories = sortedCategories.slice(8, sortedCategories.length);
        }

        return suppressedCategories;
    };

    this.SortCategoriesByPowerSumDescending = function (modelSummary, categories) {
        if (categories == null) {
            return null;
        }

        //Introduce PowerSum
        var category, attributes;
        for (var i = 0; i < categories.length; i++) {
            category = categories[i];
            attributes = this.GetAttributesByCategory(modelSummary, category.name, category.color, 3);
            category.PowerSum = _.reduce(attributes, function(acc, e) { return acc + e.power; }, 0);
        }

        //Sort Descending and Remove PowerSum
        categories = _.sortBy(categories, function(e) { return -e.PowerSum; });
        _.each(categories, function(e) { delete e.PowerSum; });
        return categories;
    };

    this.PredictorHasValidBuckets = function (predictor, totalLeads) {
        if (predictor == null || totalLeads == null) {
            return false;
        }
        var toReturn = true;
        for (var y = 0; y < predictor.Elements.length; y++) {
            var element = predictor.Elements[y];
            var attributeValue = AnalyticAttributeUtility.GetAttributeBucketName(element, predictor);
            var percentTotal = (element.Count / totalLeads) * 100;
            if (attributeValue != null &&
                (attributeValue.toUpperCase() == "NULL" || attributeValue.toUpperCase() == "NOT AVAILABLE" ||
                            attributeValue === "") && 
                percentTotal >= 99.5) {
                toReturn = false;
                break;
            }
        }

        return toReturn;
    };

    this.GetAttributesByCategory = function (modelSummary, categoryName, categoryColor, maxNumber) {
        if (StringUtility.IsEmptyString(categoryName) || modelSummary.Predictors == null  || maxNumber == null) {
            return [];
        }

        var totalPredictors = [];
        for (var i = 0; i < modelSummary.Predictors.length; i++) {
            if (categoryName == modelSummary.Predictors[i].Category) {
                totalPredictors.push(modelSummary.Predictors[i]);
            }
        }
        totalPredictors = totalPredictors.sort(this.SortByPredictivePower);

        var toReturn = [];
        for (var x = 0; x < totalPredictors.length; x++) {
            if (toReturn.length == maxNumber) {
                break;
            }
            var predictor = totalPredictors[x];
            if (AnalyticAttributeUtility.IsAllowedForInsights(predictor) &&
                        this.PredictorHasValidBuckets(predictor, modelSummary.ModelDetails.TotalLeads) &&
                (this.ShowBasedOnInternalOrExternal(predictor, true) || this.ShowBasedOnInternalOrExternal(predictor, false))) {

                var displayPredictor = {
                  name: predictor.Name,
                  categoryName: categoryName,
                  power: predictor.UncertaintyCoefficient,
                  size: 1,
                  color: categoryColor
                };
                toReturn.push(displayPredictor);
            }
        }
        return toReturn;
    };

    this.ShowBasedOnInternalOrExternal = function (predictor, isExternal) {
        var toReturn = false;
        var tag = isExternal ? "External" : "Internal";
        if (predictor != null && predictor.Tags != null) {
            for (var x=0; x<predictor.Tags.length; x++) {
                if (tag == predictor.Tags[x]) {
                    toReturn = true;
                    break;
                }
            }
        }
        
        return toReturn;
    };
    
    this.GetNumberOfAttributesByCategory = function (categoryList, isExternal, modelSummary) {
        var toReturn = {
            totalAttributeValues: 0,
            total: 0,
            categories: []
        };
        if (categoryList == null || isExternal == null || modelSummary.Predictors == null) {
            return toReturn;
        }
        for (var x = 0; x < categoryList.length; x++) {
            var category = categoryList[x];
            var displayCategory = {
                name: category.name,
                count: 0,
                color: category.color,
                activeClass: ""
            };

            for (var i = 0; i < modelSummary.Predictors.length; i++) {
                var predictor = modelSummary.Predictors[i];

                if (predictor.Category == category.name &&
                    this.ShowBasedOnInternalOrExternal(predictor, isExternal) &&
                    AnalyticAttributeUtility.IsAllowedForInsights(predictor) &&
                    this.PredictorHasValidBuckets(predictor, modelSummary.ModelDetails.TotalLeads)) {
                    for (var y = 0; y < predictor.Elements.length; y++) {
                        var element = predictor.Elements[y];
                        var percentTotal = (element.Count / modelSummary.ModelDetails.TotalLeads) * 100;
                        var isCategorical = this.IsPredictorElementCategorical(element);
                        if (isCategorical && percentTotal < 1) {
                            continue;
                        }
                        toReturn.totalAttributeValues++;
                    }
                        displayCategory.count++;
                    }
            }

            if (displayCategory.count > 0) {
                toReturn.categories.push(displayCategory);
                toReturn.total += displayCategory.count;
            }
        }
        
        return toReturn;
    };

    this.SortByCategoryName = function (a, b) {
        if (a.name.toUpperCase() < b.name.toUpperCase()) {
            return -1;
        }
        if (a.name.toUpperCase() > b.name.toUpperCase()) {
            return 1;
        }
        // a must be equal to b
        return 0;
    };

    this.SortBySize = function (a, b) {
        if (a.size > b.size) {
            return -1;
        }
        if (a.size < b.size) {
            return 1;
        }
        // a must be equal to b
        return 0;
    };

    this.SortByPredictivePower = function (a, b) {
        if (a.UncertaintyCoefficient > b.UncertaintyCoefficient) {
            return -1;
        }
        if (a.UncertaintyCoefficient < b.UncertaintyCoefficient) {
            return 1;
        }
        // a must be equal to b
        return 0;
    };

    this.SortByLift = function (a, b) {
        if (a.Lift > b.Lift) {
            return -1;
        }
        if (a.Lift < b.Lift) {
            return 1;
        }
        // a must be equal to b
        return 0;
    };

    this.AssignColorsToCategories = function (categoryList) {
        if (categoryList == null || categoryList.length === 0) {
            return;
        }
        var possibleNumberofCategories = categoryList.length <= 8 ? categoryList.length : 8;
        var colorChoices = ["#4bd1bb", "#00a2d0", "#f6b300", "#a981e1", "#95cb2c", "#9a9a9a", "#3488d3", "#e55e1b"];
        categoryList = categoryList.sort(this.SortByCategoryName);
        for (var i = 0; i < possibleNumberofCategories; i++) {
            categoryList[i].color = colorChoices[i];
        }
    };

    this.CalculateAttributeSize = function (attributeList, numLargeCategories, numMediumCategories) {
        if (attributeList == null || attributeList.length === 0) {
            return null;
        }
        
        if (numLargeCategories == null) {
            numLargeCategories = Math.round(attributeList.length * 0.16);
        }
        
        if (numMediumCategories == null) {
            numMediumCategories = Math.round(attributeList.length * 0.32);
        }

        for (var i = 0; i < attributeList.length; i++) {
            var attribute = attributeList[i];
            if (numLargeCategories > 0) {
                attribute.size = 6.55;
                numLargeCategories--;
            } else if (numMediumCategories > 0) {
                attribute.size = 2.56;
                numMediumCategories--;
            } else {
                attribute.size = 1;
            }
        }
    };

    this.IsPredictorElementCategorical = function (predictorElement) {
        if (predictorElement == null) {
            return false;
        }

        return predictorElement.LowerInclusive == null && predictorElement.UpperExclusive == null && 
            predictorElement.Values != null && predictorElement.Values.length > 0 &&
            predictorElement.Values[0] != null;
    };

    this.GetTopPredictorExport = function (modelSummary) {
        if (modelSummary == null || modelSummary.Predictors == null || modelSummary.Predictors.length === 0) {
            return null;
        }

        /*
         * Apparently, excel does not like UTF-8 characters. Handle the current offenders.
         *
         * See: http://i18nqa.com/debug/utf8-debug.html
         */
        function cleanupForExcel(text) {
          return text
              .replace("\u2019", "'")
              .replace("\u201c", "\"")
              .replace("\u201d", "\"");
        }

        var columns = [
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_CATEGORY_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_ATTRIBUTE_NAME_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_ATTRIBUTE_VALUE_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_ATTRIBUTE_DESCRIPTION_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_PERCENT_LEADS_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_LIFT_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_CONVERSION_RATE_LABEL'), 
            ResourceUtility.getString('TOP_PREDICTOR_EXPORT_PREDICTIVE_POWER_LABEL')
        ];
        var toReturn = []; 
        toReturn.push(columns);

        var totalPredictors = modelSummary.Predictors.sort(this.SortByPredictivePower);
        var averageConversionRate = modelSummary.ModelDetails.TotalConversions/modelSummary.ModelDetails.TotalLeads;

        for (var x = 0; x < totalPredictors.length; x++) {
            var predictor = totalPredictors[x];

            if(!StringUtility.IsEmptyString(predictor.Category) && 
                (this.ShowBasedOnInternalOrExternal(predictor, true) || this.ShowBasedOnInternalOrExternal(predictor, false)) &&
                AnalyticAttributeUtility.IsAllowedForInsights(predictor) &&
                this.PredictorHasValidBuckets(predictor, modelSummary.ModelDetails.TotalLeads)) {
                for (var y = 0; y < predictor.Elements.length; y++) {
                    var element = predictor.Elements[y];
                    var percentTotal = (element.Count / modelSummary.ModelDetails.TotalLeads) * 100;
                    var isCategorical = this.IsPredictorElementCategorical(element);
                    if (isCategorical && percentTotal < 1) {
                        continue;
                    }
                    percentTotal = percentTotal.toFixed(1);
                    var lift = element.Lift.toPrecision(2);
                    var conversionRate = lift * averageConversionRate;
                    var description = cleanupForExcel(predictor.Description ? predictor.Description : "");
                    var attributeValue = AnalyticAttributeUtility.GetAttributeBucketName(element, predictor);
                    if (attributeValue.toUpperCase() == "NULL" || attributeValue.toUpperCase() == "NOT AVAILABLE") {
                        attributeValue = "N/A";
                    }
                    //PLS-352 
                    attributeValue = "'"+ attributeValue + "'";
                    var predictivePower = predictor.UncertaintyCoefficient * 100;
                    var attributeRow = [predictor.Category, predictor.DisplayName, attributeValue, description, percentTotal, lift, conversionRate, predictivePower];
                    toReturn.push(attributeRow);
                }
            }
        }

        return toReturn;
    };

    this.FormatDataForTopPredictorChart = function (modelSummary) {
        if (modelSummary == null || modelSummary.Predictors == null || modelSummary.Predictors.length === 0) {
            return null;
        }

        // Get all unique categories
        var topCategories = this.GetTopCategories(modelSummary);

        // Need to assign colors based on alphabetical name, which will change the sort
        this.AssignColorsToCategories(topCategories);

        // So we need to re-sort it by UncertaintyCoefficient after the color assignment
        topCategories = topCategories.sort(this.SortByPredictivePower);

        //And finally calculate the size based on predictive power
        var attributesPerCategory = 3;
        var numLargeCategories = Math.round((topCategories.length * attributesPerCategory) * 0.16);
        var numMediumCategories = Math.round((topCategories.length * attributesPerCategory) * 0.32);
        var totalAttributes = [];
        var category;
        for (var x = 0; x < topCategories.length; x++) {
            category = topCategories[x];
            category.children = this.GetAttributesByCategory(modelSummary, category.name, category.color, attributesPerCategory);
            for (var y = 0; y < category.children.length; y++) {
                totalAttributes.push(category.children[y]);
            }
        }
        
        this.CalculateAttributeSize(totalAttributes, numLargeCategories, numMediumCategories);
        
        // Then sort the categories by the total size of their top attributes
        topCategories = topCategories.sort(this.SortBySize);
        
        var toReturn = {
            name: "root",
            size : 1,
            color: "#FFFFFF",
            attributesPerCategory: attributesPerCategory,
            children: topCategories
        };
        
        return toReturn;
    };

    this.GetAttributeByName = function (attributeName, predictorList) {
        if (attributeName == null || predictorList == null) {
            return null;
        }
        
        for (var i = 0; i < predictorList.length; i++) {
            if (attributeName == predictorList[i].Name) {
                return predictorList[i];
            }
        }
        
        return null;
    };
    
   
    this.FormatDataForAttributeValueChart = function (attributeName, attributeColor, modelSummary) {
        if (attributeName == null || modelSummary == null) {
            return null;
        }
        
        var predictor = this.GetAttributeByName(attributeName, modelSummary.Predictors);
        if (predictor == null) {
            return null;
        }
        
        var toReturn = {
            name: predictor.DisplayName,
            color: attributeColor,
            description: predictor.Description || "",
            elementList: []
        };
        
        // number that comfortably fit on screen without resizing
        var maxElementsToDisplay = 7;
        var nullBucket = null;
        var otherBucket = null;
        var otherBucketElements = [];
        var topBucketCandidates = [];
        
        // Do "Other" bucketing if discrete and not boolean
        var doOtherBucket = false;
        var isContinuous = false;
        var i = 0;
        var bucket = null;
        var bucketName = null;

        if (!AnalyticAttributeUtility.IsPredictorBoolean(predictor)) {
	        for (i = 0; i < predictor.Elements.length; i++) {
	        	bucket = predictor.Elements[i];
	          	if (this.IsPredictorElementCategorical(bucket)) {
	          		doOtherBucket = true;
	          		break;
	          	} else if (bucket.LowerInclusive != null || bucket.UpperExclusive != null) {
	          		isContinuous = true;
	          		break;
	          	}
	        }
        }
        
        if (doOtherBucket) {
            // Group elements less than 1% frequency into "Other" bucket
            for (i = 0; i < predictor.Elements.length; i++) {
                bucket = predictor.Elements[i];               
                bucketName = AnalyticAttributeUtility.GetAttributeBucketName(bucket, predictor);

                var percentTotal = (bucket.Count / modelSummary.ModelDetails.TotalLeads) * 100.0;
                if (percentTotal < 1 || (bucketName != null && typeof bucketName === 'string' && bucketName.toLowerCase() == "other")) {
                    otherBucketElements.push(bucket);
                } else {
                    topBucketCandidates.push(bucket);
                }
            }      
        }
        
        var topPredictorElements = null;
        if (doOtherBucket) {
            topPredictorElements = topBucketCandidates;
        } else {
            topPredictorElements = predictor.Elements;
        }
        
        for (i = 0; i < topPredictorElements.length; i++) {
            
            bucket = topPredictorElements[i];
            bucketName = AnalyticAttributeUtility.GetAttributeBucketName(bucket, predictor);
            
            var bucketToDisplay = {
                name: bucketName,
                lift: bucket.Lift,
                percentTotal: (bucket.Count / modelSummary.ModelDetails.TotalLeads) * 100.0
            };
            
            // Set sort property based on whether it is a discrete versus a continuous value
            if (isContinuous) {
                bucketToDisplay.SortProperty = bucket.LowerInclusive != null ? bucket.LowerInclusive : bucket.UpperExclusive;
                // Only when the attribute is continuous, sorting is increasing order
            } else {
                bucketToDisplay.SortProperty = bucketToDisplay.lift;
            }
            
            if (bucket.IsVisible) {
                // Always sort NA bucket to the bottom
                if (bucketToDisplay.name != null && typeof bucketToDisplay.name === 'string' &&
                    (bucketToDisplay.name.toUpperCase() === "NULL" || bucketToDisplay.name.toUpperCase() === "NONE" || bucketToDisplay.name.toUpperCase() === "NOT AVAILABLE")) {
                    nullBucket = bucketToDisplay;                        
                    nullBucket.name = "N/A";
                    continue;
                }
                toReturn.elementList.push(bucketToDisplay);
            }
        }
          
        // sort the list of buckets
        toReturn.elementList.sort(function (a, b)  {
            if (a.SortProperty < b.SortProperty) {
                return isContinuous ? -1 : 1;
            }
            if (a.SortProperty == b.SortProperty) {
                return 0;
            }
            if (a.SortProperty > b.SortProperty) {
                return isContinuous ? 1 : -1;
            }
                return 0;
        });
        
        var nullBucketLength = nullBucket == null ? 0 : 1;
        var otherBucketLength = otherBucketElements.length > 0 ? 1 : 0; 
        var currentTotalNumBuckets = toReturn.elementList.length + nullBucketLength + otherBucketLength; 
        if (currentTotalNumBuckets > maxElementsToDisplay) {
        	var numToRemove = currentTotalNumBuckets - maxElementsToDisplay;
            var removed = toReturn.elementList.splice(toReturn.elementList.length - numToRemove, numToRemove);
            Array.prototype.push.apply(otherBucketElements, removed);
        }   
        
        // Merge "Other" bucket averaged out lift and percentage
        if (otherBucketElements.length > 0) {            
            var otherBucketTotalPercentage = 0;
            var averagedLift = 0;
            for (i = 0; i < otherBucketElements.length; i++) {
                var otherBucketElement = otherBucketElements[i];
                var otherBucketPercentage = otherBucketElement.Count != null? otherBucketElement.Count / modelSummary.ModelDetails.TotalLeads :
                	otherBucketElement.percentTotal/100;
                otherBucketTotalPercentage += otherBucketPercentage;
                var otherBucketLift = otherBucketElement.Lift != null ? otherBucketElement.Lift : otherBucketElement.lift;
                averagedLift += otherBucketLift * otherBucketPercentage;
            }
            
            otherBucket = {
                name: "Other",
                lift: averagedLift / otherBucketTotalPercentage,
                percentTotal: otherBucketTotalPercentage * 100.0
            };
        }
        
        // Always sort Other bucket second from bottom  
        if (otherBucket != null) {
            toReturn.elementList.push(otherBucket);
        }   
        
        // Always sort NULL bucket to the bottom
        if (nullBucket != null) {
            toReturn.elementList.push(nullBucket);
        }

        //DP-932 
        if (isContinuous && nullBucket != null && toReturn.elementList.length == 2) {
        	toReturn.elementList[0].name = "Available";
        }
        
        return toReturn;
    };
    
    this.SumToOne = function (percentList) {
    	var topPercentage = 100.0;
        
        // Find the bucket with the largest percentage
        var index = 0;
        var maxPercentage = 0;
        for (i = 0; i < percentList.length; i++) {
            var currentPercentage = 0;
            if (typeof percentList[i] === 'string' && percentList[i] == "<0.1") {
                currentPercentage = 0.1;
            } else {
                currentPercentage = percentList[i];
            }
            
            if (currentPercentage > maxPercentage) {
                index = i;
                maxPercentage = currentPercentage;
            }
        }
        // Make the max percentage equal to 100 minus the sum of all the other percentages
        for (i = 0; i < percentList.length; i++) {
            if (i == index) {
                continue;
            } else {
            	if (typeof percentList[i] === 'string' && percentList[i] == "<0.1") {
            		topPercentage -= 0.1;
            	} else {
                	topPercentage -= percentList[i];
            	}
            }
        }
        percentList[index] = topPercentage.toFixed(1);
        
        return percentList;
    };

    this.FormatPercent = function (percent) {
        var formattedPercent = percent;
        if (formattedPercent >= 0.95) {
            formattedPercent = Math.round(formattedPercent);
        } else if (formattedPercent <= 0.95 && formattedPercent >= 0.1) {
            formattedPercent = Number(formattedPercent.toFixed(1));
        } else {
            formattedPercent = "<0.1";
        }
        return formattedPercent;
    };
    
    this.createTicks = function(maxTickValue, maxTickNumber) {
        var steps = [0.5, 1, 2, 5, 10];
        // iterate options in steps, find the maximum appropriate step
        var step = _.reduce(steps, function(memo, s){
            return (maxTickNumber * memo >= maxTickValue) ? memo : s;
        }, 0);
        // continue doubling step until find an appropriate one
        while (maxTickNumber * step < maxTickValue) {
            step *= 2;
        }
        // construct ticks
        var tick = 0;
        var ticks = [tick];
        while (tick < maxTickValue) {
            tick += step;
            ticks.push(tick);
        }

        return ticks;
    };

    this.ClearCategoryClasses = function (categoryList) {
        if (categoryList == null || categoryList.length === 0) {
            return;
        }
        
        for (var i = 0; i < categoryList.length; i++) {
            categoryList[i].activeClass = "";
        }
    };
});
angular.module('mainApp.appCommon.services.WidgetFrameworkService', [
    'mainApp.appCommon.utilities.WidgetConfigUtility',
    'mainApp.appCommon.utilities.MetadataUtility',
    'mainApp.appCommon.widgets.RepeaterWidget',
    'mainApp.appCommon.widgets.ScreenWidget',
    'mainApp.appCommon.widgets.ArcChartWidget',
    'mainApp.appCommon.widgets.CollapsiblePanelWidget',
    'mainApp.appCommon.widgets.ScreenHeaderWidget',
    'mainApp.appCommon.widgets.SimpleGridWidget',
    'mainApp.appCommon.widgets.SimpleTabWidget',
    'mainApp.appCommon.widgets.TabWidget',
    'mainApp.appCommon.widgets.TopPredictorWidget',
    'mainApp.appCommon.widgets.ThresholdExplorerWidget',
    'mainApp.appCommon.widgets.PerformanceTabWidget',
    'mainApp.appCommon.widgets.UserManagementWidget',
    'mainApp.appCommon.widgets.AdminInfoSummaryWidget',
    'mainApp.appCommon.widgets.AdminInfoAlertsWidget',
    'mainApp.appCommon.widgets.LeadsTabWidget',
    'mainApp.appCommon.widgets.ModelListCreationHistoryWidget',
    'mainApp.appCommon.widgets.ManageFieldsWidget'
])
.service('WidgetFrameworkService', function ($compile, $rootScope, WidgetConfigUtility, MetadataUtility) {

    this.CreateWidget = function (options) {
        if (options == null || options.element == null || options.widgetConfig == null) {
            return;
        }


        var root = $rootScope;
        var scope = root.$new();
        scope.data = options.data;
        scope.parentData = options.parentData;
        scope.metadata = options.metadata;
        scope.widgetConfig = options.widgetConfig;
        scope.element = options.element;
        scope.isActive = options.isActive;

        // alphabetical order please
        switch (options.widgetConfig.Type) {
            case WidgetConfigUtility.ANALYTIC_ATTRIBUTE_LIST_WIDGET:
                $compile(options.element.html('<div data-analytic-attribute-list-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.ANALYTIC_ATTRIBUTE_TILE_WIDGET:
                $compile(options.element.html('<div data-analytic-attribute-tile-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.ARC_CHART_WIDGET:
                $compile(options.element.html('<div data-arc-chart-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.COLLAPSIBLE_PANEL_WIDGET:
                $compile(options.element.html('<div data-collapsible-panel-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.GRID_WIDGET:
                //TODO:pierce options.$element.grid_widget(widgetOptions);
                break;
            case WidgetConfigUtility.LEAD_DETAILS_TILE_WIDGET:
                $compile(options.element.html('<div data-lead-details-tile-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.MODEL_DETAILS_WIDGET:
                $compile(options.element.html('<div data-model-details-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.MODEL_LIST_TILE_WIDGET:
                $compile(options.element.html('<div data-model-list-tile-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.MODEL_LIST_CREATION_HISTORY:
                $compile(options.element.html('<div data-model-list-creation-history-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.PLAY_DETAILS_TILE_WIDGET:
                $compile(options.element.html('<div data-play-details-tile-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.PLAY_LIST_TILE_WIDGET:
                $compile(options.element.html('<div data-play-list-tile-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.REPEATER_WIDGET:
                $compile(options.element.html('<div data-repeater-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.SCREEN_WIDGET:
                $compile(options.element.html('<div data-screen-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.SCREEN_HEADER_WIDGET:
                $compile(options.element.html('<div data-screen-header-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.SIMPLE_GRID_WIDGET:
                $compile(options.element.html('<div data-simple-grid-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.SIMPLE_TAB_WIDGET:
                $compile(options.element.html('<div data-simple-tab-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.TALKING_POINT_WIDGET:
                $compile(options.element.html('<div data-talking-point-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.TAB_WIDGET:
                $compile(options.element.html('<div data-tab-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.TEST_WIDGET:
                //TODO:pierce options.$element.test_widget(widgetOptions);
                break;
            case WidgetConfigUtility.THRESHOLD_EXPLORER_WIDGET:
                $compile(options.element.html('<div data-threshold-explorer-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.PERFORMANCE_TAB_WIDGET:
                $compile(options.element.html('<div data-performance-tab-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.TOP_PREDICTOR_WIDGET:
                $compile(options.element.html('<div data-top-predictor-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.ADMIN_INFO_SUMMARY_WIDGET:
                $compile(options.element.html('<div data-admin-info-summary-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.ADMIN_INFO_ALERTS_WIDGET:
                $compile(options.element.html('<div data-admin-info-alerts-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.LEADS_TAB_WIDGET:
                $compile(options.element.html('<div data-leads-tab-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.USER_MANAGEMENT_WIDGET:
                $compile(options.element.html('<div data-user-management-widget></div>'))(scope);
                break;
            case WidgetConfigUtility.MANAGE_FIELDS_WIDGET:
                $compile(options.element.html('<div data-manage-fields-widget></div>'))(scope);
                break;
            default:
                return;
        }
    };

    this.CreateChildWidgets = function (options, dataForChildren) {
        var numLayoutColumns = options.widgetConfig.Columns || 1;
        this.CreateChildWidgetsInColumnLayout(options, dataForChildren, numLayoutColumns);
    };

    this.CreateChildWidgetsInColumnLayout = function (options, dataForChildren, numLayoutColumns) {
        var self = this;

        if (options == null || options.widgetConfig == null) {
            return;
        }

        var children = options.widgetConfig.Widgets;
        if (children == null) {
            return;
        }

        self.CreateWidgetsInColumnLayout(
            options.element,
            children.length,
            numLayoutColumns,
            function (childElement, numItems, childIndex) {
                self.CreateChildWidget(
                    options, childElement, children, dataForChildren, numItems, childIndex);
            }
        );
    };

    this.CreateWidgetsInColumnLayout = function (element, numItems, numCols, createWidgetCallback) {
        // Only create the extra column layout HTML for multi-column layouts
        var isMultiCol = ((numCols !== 1) && (typeof numCols === "number"));

        var colClass = 'layout-column';

        if (isMultiCol) {
            this.CreateLayoutColumnHtml(element, numCols, colClass);
        }

        var numItemsPerCol = Math.floor(numItems / numCols);

        // The number of left over items (when items do not divide evenly into columns),
        // we will spread these out evenly across columns
        var leftoverItems = numItems % numCols;

        var curColNum = 0;
        var curColItemCount = 0;

        for (var i = 0; i < numItems; i++) {
            var childElement = $('<div></div>');

            if (isMultiCol) {
                // Figure out if we should move to the next column
                if (curColItemCount >= numItemsPerCol) {
                    // current column is full but can fit a leftover
                    if (leftoverItems > 0 && (curColItemCount == numItemsPerCol)) {
                        leftoverItems--;
                    } else { // current column has filled up (including leftovers), move to next
                        curColNum++;
                        curColItemCount = 0;
                    }
                }
                curColItemCount++;
                this.AddItemToColumn(element, colClass, curColNum, childElement);
            } else {
                this.AddItemToElement(element, childElement);
            }

            if (typeof createWidgetCallback === "function") {
                createWidgetCallback(childElement, numItems, i);
            }
        }
    };

    this.CreateLayoutColumnHtml = function (element, numCols, colClass) {
        var colWidth = 100 / numCols;
        for (var col = 0; col < numCols; col++) {
            var cols = $('<div class="float-left ' + colClass + ' ' + colClass + '-' + col + '"></div>');
            $(element).append(cols);
            cols.css("width", colWidth + "%"); // must add percent sign otherwise will be pixels
        }
    };

    this.AddItemToColumn = function (element, colClass, curColNum, item) {
        var curCol = $(element).find('.' + colClass + '-' + curColNum);
        $(curCol).append(item);
    };

    this.AddItemToElement = function (element, item) {
        $(element).append(item);
    };

    this.CreateChildWidget = function (options, childElement, children, dataForChildren, numChildren, index) {
        var child = children[index];
        var childData = this.GetChildDataAtIndex(dataForChildren, numChildren, index);
        var childIsActive = options.isActive;

        this.CreateWidget({
            scope: options.scope,
            element: childElement,
            widgetConfig: child,
            metadata: options.metadata,
            data: childData,
            parentData: options.parentData,
            isActive: childIsActive
        });
    };

    this.IsChildActive = function (activeWidgetStates, childIndex, numChildren) {
        if (!Array.isArray(activeWidgetStates)) {
            return true;
        }

        var isAllActive = (activeWidgetStates.indexOf(WidgetConfigUtility.ACTIVE_WIDGET_ALL) !== -1),
            isEvenActive = (activeWidgetStates.indexOf(WidgetConfigUtility.ACTIVE_WIDGET_EVEN) !== -1),
            isFirstActive = (activeWidgetStates.indexOf(WidgetConfigUtility.ACTIVE_WIDGET_FIRST) !== -1),
            isLastActive = (activeWidgetStates.indexOf(WidgetConfigUtility.ACTIVE_WIDGET_LAST) !== -1),
            isNoneActive = (activeWidgetStates.indexOf(WidgetConfigUtility.ACTIVE_WIDGET_NONE) !== -1),
            isOddActive = (activeWidgetStates.indexOf(WidgetConfigUtility.ACTIVE_WIDGET_ODD) !== -1),
            isChildActive = false;

        // Note: All takes precedence over None,
        // so ["All", "None"] and ["None", "All"] both evaluate to "All" 
        if (isAllActive) {
            isChildActive = true;
        } else if (isNoneActive) {
            isChildActive = false;
        } else if (isEvenActive || isFirstActive || isLastActive || isOddActive) {
            // values that can be combined
            if (isEvenActive) {
                isChildActive = isChildActive || ((childIndex + 1) % 2 === 0);
            }
            if (isFirstActive) {
                isChildActive = isChildActive || (childIndex === 0);
            }
            if (isLastActive) {
                isChildActive = isChildActive || (childIndex === numChildren - 1);
            }
            if (isOddActive) {
                isChildActive = isChildActive || ((childIndex + 1) % 2 !== 0);
            }
        } else { // no valid active widget states specified
            isChildActive = true;
        }

        return isChildActive;
    };

    this.GetChildDataAtIndex = function (dataForChildren, numChildren, index) {
        var childData = null;

        // if data for children is an array, use the correct index
        if (dataForChildren instanceof Array &&
            dataForChildren.length === numChildren) {
            childData = dataForChildren[index];
        } else { // otherwise data applies for all children
            childData = dataForChildren;
        }

        return childData;
    };

    // Get a list of properties to sort on (in the form that SortUtil expects)
    // given the Sorts specified in a WidgetConfig
    this.GetSortProperties = function (widgetConfig, metadata) {
        if (widgetConfig == null) {
            return [];
        }

        var widgetConfigSorts = widgetConfig.Sorts;
        if (!(widgetConfigSorts instanceof Array)) {
            return [];
        }

        if (metadata == null) {
            return [];
        }

        var targetNotionMetadata = MetadataUtility.GetNotionMetadata(widgetConfig.TargetNotion, metadata);

        var propsToSortOn = [];
        for (var i = 0; i < widgetConfigSorts.length; i++) {
            var widgetConfigSort = widgetConfigSorts[i];
            if (widgetConfigSort == null) {
                continue;
            }

            var propName = widgetConfigSort.Property;
            var propIsAscending = widgetConfigSort.IsAscending;

            var metadataProperty = MetadataUtility.GetNotionProperty(
                propName, targetNotionMetadata);
            var propTypeString = (metadataProperty != null) ? metadataProperty.PropertyTypeString : null;
            var propCompareFunction = MetadataUtility.GetCompareFunction(propTypeString);

            var prop = {
                Name: propName,
                IsAscending: propIsAscending,
                CompareFunction: propCompareFunction
            };
            propsToSortOn.push(prop);
        }

        return propsToSortOn;
    };
});
angular.module('mainApp.appCommon.modals.SimpleModal', [
    'mainApp.appCommon.utilities.ResourceUtility'
])
.service('SimpleModal', function (ResourceUtility) {
    
    this.show = function (overrides, okCallback) {
        
        var options = {
            showCloseButton: true,
            height: 250,
            width: 500,
            title: "",
            message: "",
            okButtonLabel: ResourceUtility.getString("BUTTON_OK_LABEL")
        };
        
        angular.extend(options, overrides);
        
        var modalClass = "no-close-button";
        var modalElement = $('<div></div>');
        modalElement.html(options.message);
        modalElement.dialog({
            height: options.height,
            width: options.width,
            autoOpen: false,
            closeOnEscape: false,
            modal: true,
            title: options.title,
            dialogClass: options.showCloseButton === true ? '' : modalClass,
            buttons: [
                {
                    text: options.okButtonLabel,
                    click: function () {
                        if (okCallback != null && typeof okCallback === 'function') {
                            okCallback();
                        }
                        modalElement.dialog("close");
                    }
                }
            ],
            close: function (evt, ui) {
                modalElement.remove();
            }
       });
       
       modalElement.dialog("open" );
    };
});

angular.module('mainApp', [
'720kb.tooltips'
]);